<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Document Summarizer</title>
    <script src="./javascripts/sas/util/messagingUtil.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <!-- PDF.js library for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/dompurify@3.1.6/dist/purify.min.js"
        integrity="sha384-+VfUPEb0PdtChMwmBcBmykRMDd+v6D/oFmB3rZM/puCMDYcIvF968OimRh4KQY9a" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <style>
        /* ===== Theme + base ===== */
        :root {
            --bg: #fff;
            --fg: #1d1d1f;
            --muted: #6e6e73;
            --card: #fff;
            --border: rgba(0, 0, 0, .08);
            --primary: #0478CE;
            --primary-press: #0366AF;
            --grey-soft: #fafafa;
            --primary-soft: #E8F3FF;
            --content-indent: 14px;
            --file-wave-min: .5;
            /* lowest visibility (0..1). Try .9 if you want even subtler */
            --file-wave-width: 30%;
            /* width of the soft band */
            --file-wave-speed: 2.8s;
            /* animation speed */
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, system-ui
        }

        .container {
            width: min(96vw, 1600px);
            margin: 2vh auto 8vh;
            padding: 0 24px
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 24px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, .04), 0 8px 30px rgba(0, 0, 0, .06);
            padding: 24px 24px 28px;
            display: grid;
            gap: 18px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px
        }

        h1 {
            margin: 0 0 6px 0;
            font-size: 28px;
            font-weight: 650;
            letter-spacing: -.02em
        }

        .subtitle {
            margin: 0;
            color: var(--muted);
            font-size: 14px
        }

        .header>div:first-child {
            padding-left: var(--content-indent)
        }

        /* Labels + surfaces */
        .label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: .08em;
            color: var(--muted);
            margin-bottom: 8px;
            padding-left: var(--content-indent)
        }

        .surface {
            border: 1px solid var(--border);
            border-radius: 14px;
            background: var(--grey-soft);
            padding: 14px;
            overflow: auto;
            font-size: 14px
        }

        /* Layout */
        .grid {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 18px;
            min-height: 500px;
        }

        .left {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 80vh;
            /* Limit collection height but allow it to grow */
            position: sticky;
            top: 20px;
            /* Keep collection visible when scrolling */
        }

        .left .surface {
            flex: 1;
            min-height: 0;
        }

        .right {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: stretch;
        }

        .right>section {
            display: flex;
            flex-direction: column;
        }

        .right>section:first-child {
            flex-shrink: 0;
            /* Keep file content at fixed height */
        }

        .right>section:last-child {
            flex: 1 0 auto;
            /* Allow summary to expand */
        }

        .right .surface {
            flex: 1;
            min-height: 0;
        }

        /* Force a taller summary pane before content renders */
        .right .summary-box {
            min-height: 320px;
        }

        /* File list */
        .search {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            position: relative;
        }

        .search-wrapper {
            position: relative;
            width: 100%;
        }

        .search input {
            width: 100%;
            padding: 10px 36px 10px 12px;
            border: 1px solid var(--border);
            border-radius: 14px;
            background: #fff;
            outline: none;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: var(--muted);
            transition: all 0.15s ease;
        }

        .search-clear:hover {
            background: rgba(0, 0, 0, 0.06);
            color: var(--fg);
        }

        .search-clear.visible {
            display: flex;
            /* Show when visible class is added */
        }

        /* The X icon using CSS */
        .search-clear::before,
        .search-clear::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 1.5px;
            background: currentColor;
            border-radius: 1px;
        }

        .search-clear::before {
            transform: rotate(45deg);
        }

        .search-clear::after {
            transform: rotate(-45deg);
        }


        .filelist {
            display: grid;
            gap: 8px
        }


        .file {
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 10px;
            background: #fff;
            cursor: pointer;
            display: grid;
            gap: 2px
        }

        .file:hover {
            background: var(--grey-soft);
            border-color: var(--border)
        }

        .file.is-active {
            background: var(--primary-soft);
            border-color: #CFE7FF
        }

        .file .name {
            font-weight: 600
        }

        .file .meta {
            font-size: 12px;
            color: var(--muted)
        }

        /*  special "All Documents" row + separator */
        .filelist .divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        .file.all-docs .meta {
            font-style: italic
        }


        /* Button */
        .row {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .btn-primary {
            appearance: none;
            border: none;
            cursor: pointer;
            background: var(--primary);
            color: #fff;
            border-radius: 14px;
            padding: 12px 18px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
        }

        .btn-primary:hover {
            filter: brightness(1.02)
        }

        .btn-primary:active {
            transform: scale(.985)
        }

        .btn-primary:disabled {
            opacity: .65;
            cursor: not-allowed;
            box-shadow: none
        }

        .btn-primary:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(4, 120, 206, .12)
        }

        /* Make button host spinner + label inline */
        .btn-primary {
            display: inline-flex;
            /* ADD */
            align-items: center;
            /* ADD */
            gap: 8px;
            /* ADD */
            transition: transform .06s, box-shadow .2s, filter .2s;
            /* ADD */
        }

        /* Inline spinner exactly like other app */
        .spinner {
            /* ADD */
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, .6);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        /* Swap label <-> spinner while loading */
        .loading .spinner {
            display: inline-block;
        }

        .loading .labeltext {
            display: none;
        }

        /* Remove top margins from ALL first elements inside these containers */
        #summaryContent>*:first-child,
        #summaryContent article:first-child,
        #summaryContent h1:first-child,
        #summaryContent h2:first-child,
        #summaryContent h3:first-child,
        #summaryContent p:first-child {
            margin-top: 0 !important;
        }

        /* Also ensure article elements don't add spacing */
        #summaryContent article {
            margin: 0;
            padding: 0;
        }

        /* Ensure all heading elements inside summary don't add extra top margin when they're first */
        #summaryContent>article>*:first-child {
            margin-top: 0 !important;
        }

        /* Fix any potential spacing from the muted text spans */
        .muted {
            color: var(--muted);
            display: inline-block;
            margin: 0;
            padding: 0;
        }

        /* Ensure the processing-status doesn't add margin */
        .processing-status {
            color: var(--primary);
            font-style: italic;
            margin: 0;
            padding: 0;
        }


        #summaryContent {
            word-wrap: break-word;
            font-family: inherit;
            margin: 0;
        }

        /* Add these new rules */
        #summaryContent>*:first-child {
            margin-top: 0;
        }

        #summaryContent>*:last-child {
            margin-bottom: 0;
        }

        /* normal HTML flow */

        /* Status message */
        #out {
            display: none;
        }

        .processing-status {
            color: var(--primary);
            font-style: italic
        }

        .muted {
            color: var(--muted)
        }

        /* Loading state */
        .loading-message {
            color: var(--muted);
            font-style: italic;
            padding: 8px;
        }

        /* Responsive */
        @media (max-width:1024px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .left {
                max-height: 300px;
                position: relative;
                top: auto;
            }
        }


        .summary-box {
            min-height: 200px;
            /* Ensure minimum height */
            max-height: none;
            /* Allow unlimited expansion */
        }

        /* Skeleton loader (flowing opaque lines) */
        .skel {
            display: grid;
            gap: 8px;
            margin: 0;
        }

        .skel .line {
            height: 10px;
            border-radius: 6px;
            background: linear-gradient(90deg, #ececec, #f7f7f7, #ececec);
            background-size: 200% 100%;
            animation: shimmer 2.5s linear infinite;
        }

        /* make skeleton non-selectable */
        .skel,
        .skel * {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        /* === VIEW TOGGLE (Summary <-> Chat) === */
        .viewtoggle {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0;
            width: 200px;
            height: 36px;
            padding: 4px;
            border-radius: 999px;
            background: var(--grey-soft);
            border: 1px solid var(--border);
            font-weight: 600;
            user-select: none;
            cursor: pointer
        }

        .viewtoggle .label {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            margin: 0;
            padding: 0;
            text-transform: none;
            letter-spacing: 0;
            line-height: 1;
            color: var(--muted);
            position: relative;
            z-index: 1
        }

        .viewtoggle .pill {
            position: absolute;
            top: 4px;
            left: 4px;
            height: 28px;
            width: calc(50% - 4px);
            border-radius: 999px;
            background: var(--primary);
            box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
            transition: transform .0s;
            z-index: 0;
            pointer-events: none
        }

        .card:not(.show-chat) .viewtoggle .label:first-child,
        .card.show-chat .viewtoggle .label:nth-child(2) {
            color: #fff !important
        }

        .card.show-chat .viewtoggle .pill {
            transform: translateX(100%)
        }

        /* Hide Summarize button in Chat mode (same behavior as Alert app) */
        .card.show-chat #summarizeBtn {
            display: none
        }

        /* Pane visibility control */
        #pane-chat {
            display: none
        }

        .card.show-chat #pane-chat {
            display: block
        }

        .card.show-chat #pane-summary {
            display: none
        }

        /* Inline disclaimer in Chat mode */
        .card.show-chat::after {
            content: "Generative AI can make mistakes. Check important info.";
            display: block;
            margin-top: 7px;
            font-size: 13px;
            color: var(--muted);
            text-align: center
        }

        /* === CHAT UI (reused from Alert Summarizer) === */
        .chat {
            border: 1px solid var(--border);
            border-radius: 14px;
            background: var(--grey-soft);
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .chat-messages {
            min-height: 273px;
            max-height: clamp(360px, 55vh, 720px);
            overflow: auto;
            display: grid;
            gap: 10px;
            padding-right: 4px;
            align-content: start;
            align-items: start;
            grid-auto-rows: max-content
        }

        .msg {
            display: flex
        }

        .msg .bubble {
            border: 1px solid var(--border);
            background: #f7f7f7;
            color: var(--fg);
            padding: 10px 12px;
            border-radius: 14px 14px 4px 14px;
            font-size: 14px;
            line-height: 1.35;
            max-width: 72%;
            box-shadow: 0 1px 2px rgba(0, 0, 0, .04)
        }

        .msg.bot .bubble {
            background: #fff;
            color: var(--fg);
            border-color: var(--border)
        }

        .msg.user {
            justify-content: flex-end
        }

        .msg.user .bubble {
            background: var(--primary-soft);
            color: var(--fg);
            border-color: var(--border);
            border-radius: 14px 14px 14px 4px
        }

        .chat-input {
            display: flex;
            gap: 8px
        }

        #chatText {
            flex: 1;
            border: 1px solid rgba(0, 0, 0, .12);
            border-radius: 14px;
            padding: 12px 14px;
            font: inherit;
            outline: none
        }

        #chatText:focus {
            border-color: var(--primary-press);
            box-shadow: 0 0 0 4px rgba(10, 132, 255, .12)
        }

        .typing {
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        .typing .dots {
            display: inline-flex;
            gap: 4px
        }

        .typing .dots i {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--muted);
            opacity: .35;
            animation: dotpulse 1s ease-in-out infinite
        }

        .typing .dots i:nth-child(2) {
            animation-delay: .2s
        }

        .typing .dots i:nth-child(3) {
            animation-delay: .4s
        }

        /* reuse existing @keyframes dotpulse from Alert app via your spinner keyframes; if absent, add: */
        @keyframes dotpulse {

            0%,
            100% {
                transform: translateY(0);
                opacity: .25
            }

            50% {
                transform: translateY(-3px);
                opacity: 1
            }
        }

        /* === Small icon button on file rows === */
        .icon-btn {
            appearance: none;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            line-height: 0;
        }

        .icon-btn:hover {
            background: rgba(0, 0, 0, .05);
        }

        .icon-btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(4, 120, 206, .15);
        }

        /* If using an <img> inside the icon button */
        .icon-btn img {
            display: block;
            width: 16px;
            height: 16px;
        }

        /* File row layout now has an actions area on the right */
        .file {
            display: flex;
            /* <-- was grid */
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .file .main {
            display: grid;
            gap: 2px;
        }

        .file .actions {
            flex: 0 0 auto;
        }

        /* === Fullscreen-ish modal === */
        .content-modal[hidden] {
            display: none;
        }

        .content-modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .content-modal__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, .4);
        }

        .content-modal__panel {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: min(1000px, 94vw);
            height: min(80vh, 900px);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 18px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-modal__header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
        }

        .content-modal__title {
            margin: 0;
            font-size: 16px;
            font-weight: 650;
        }

        .content-modal__body {
            padding: 12px 16px;
            overflow: auto;
            background: var(--grey-soft);
            height: 100%;
        }

        #modalFileContent {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Close button inherits .icon-btn; make it a bit larger */
        .close-btn {
            font-size: 22px;
            padding: 2px 8px;
            line-height: 1;
        }

        /* Optional: when modal is open, prevent page scroll */
        body.modal-open {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card" role="region" aria-labelledby="title">
            <!-- Header with title and summarize button -->
            <div class="header">
                <div>
                    <h1 id="title">Document Summarizer</h1>
                    <p class="subtitle">Generate a concise summary with one click.</p>
                </div>
                <div class="row">
                    <!-- Summarize stays in header; auto-hidden in Chat mode via CSS -->
                    <button id="summarizeBtn" class="btn-primary" type="button" disabled aria-busy="false">
                        <span class="spinner" aria-hidden="true"></span>
                        <span class="labeltext">Summarize</span>
                    </button>
                    <!-- Segmented control: Summary <-> Chat -->
                    <div id="viewToggle" class="viewtoggle" role="switch" aria-checked="false"
                        aria-label="Toggle summary or chat">
                        <span class="label">Summary</span>
                        <span class="label">Chat</span>
                        <span class="pill" aria-hidden="true"></span>
                    </div>
                </div>
            </div>

            <!-- Content Modal -->
            <div id="contentModal" class="content-modal" hidden>
                <div class="content-modal__backdrop" data-close="true" aria-hidden="true"></div>

                <div class="content-modal__panel" role="dialog" aria-modal="true" aria-labelledby="contentModalTitle">
                    <div class="content-modal__header">
                        <h2 id="contentModalTitle" class="content-modal__title">Document content</h2>
                        <button id="contentModalClose" class="icon-btn close-btn" type="button"
                            aria-label="Close">&times;</button>
                    </div>

                    <div class="content-modal__body">
                        <pre id="modalFileContent">Loading…</pre>
                    </div>
                </div>
            </div>

            <!-- Main grid layout -->
            <div class="grid">
                <!-- Left: Documents -->
                <aside class="left" aria-label="Documents">
                    <div>
                        <div class="label">Documents</div>
                        <div class="search">
                            <div class="search-wrapper">
                                <input id="searchInput" placeholder="Search documents…" />
                                <button id="searchClear" class="search-clear" type="button"
                                    aria-label="Clear search"></button>
                            </div>
                        </div>
                    </div>
                    <div class="surface">
                        <div id="filelist" class="filelist">
                            <div class="loading-message">Waiting for VA parameters...</div>
                        </div>
                    </div>
                </aside>

                <!-- Right: File Content + Summary -->
                <main class="right">
                    <div id="pane-summary">
                        <section>
                            <div class="label">Summary</div>
                            <div class="surface summary-box" aria-label="AI Summary">
                                <div id="summaryContent" aria-live="polite">
                                    <span class="muted">AI summary will appear here...</span>
                                </div>
                            </div>
                        </section>
                    </div>

                    <div id="pane-chat">
                        <section>
                            <div class="label">Chat</div>
                            <div class="chat" id="chat">
                                <div id="chatMessages" class="chat-messages" role="region" aria-live="polite"></div>
                                <div class="chat-input">
                                    <input id="chatText" type="text" placeholder="Ask about this document…" />
                                    <button id="chatSendBtn" class="btn-primary" type="button" disabled>Send</button>
                                </div>
                            </div>
                        </section>
                    </div>
                </main>
            </div>

            <!-- Hidden elements for compatibility -->
            <div id="out" style="display:none"></div>
            <select id="fileSelect" style="display:none">
                <option value="">— select a file —</option>
            </select>
            <small id="fileCount" style="display:none"></small>
        </div>
    </div>

    <script>
        /**
         * VA Document Summarizer Application
         * Modular architecture for maintainability and future development
         */
        const DocumentSummarizerApp = (() => {
            // =============================================================================
            // CONFIGURATION
            // =============================================================================
            const CONFIG = {
                SAS_SERVER: 'https://sasserver.demo.sas.com',
                SAS_AUTH: {
                    CLIENT_ID: 'sas.cli', // Default SAS CLI client ID
                    CLIENT_SECRET: '', // Usually empty for CLI client
                    TOKEN_ENDPOINT: '/SASLogon/oauth/token'
                },
                PARAMETER_INDEXES: {
                    alertId: 0,
                    openaiKey: 1,
                    sasUser: 2,
                    sasPass: 3
                },
                VA_RETRY_INTERVAL: 1000,
                ELEMENTS: {
                    output: 'out',
                    fileSelect: 'fileSelect',
                    fileCount: 'fileCount',
                    summarizeBtn: 'summarizeBtn',
                    summaryContent: 'summaryContent',
                    filelist: 'filelist',
                    searchInput: 'searchInput',
                    viewToggle: 'viewToggle',
                    chatText: 'chatText',
                    chatSendBtn: 'chatSendBtn',
                    chatMessages: 'chatMessages'
                },
                OPENAI: {
                    URL: 'https://api.openai.com/v1/responses',
                    MODEL: 'gpt-5-nano'
                },
                PDF: {
                    WORKER_SRC: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
                },
                AUTO_REFRESH: {
                    ENABLED: true,
                    INTERVAL: 4000 // milli seconds
                },
                PRELOAD: {
                    ENABLED: true,
                    COUNT: 10,     // how many files to preload
                    DELAY: 200    // ms between requests to be gentle on the server
                },
                HEADINGS: {
                    summary: {
                        title: 'Document Summarizer',
                        subtitle: 'Generate a concise summary with one click.'
                    },
                    chat: {
                        title: 'Document Chat',
                        subtitle: 'Ask questions about this document.'
                    }
                },
                SPECIAL: {
                    ALL_ID: '__ALL__',
                    ALL_NAME: 'All Documents'
                }
            };

            // Strict allow-list for LLM HTML (blocks scripts, styles, events, links, etc.)
            const SANITIZE = (html) => DOMPurify.sanitize(html, {
                ALLOWED_TAGS: ['article', 'h2', 'h3', 'p', 'ul', 'ol', 'li', 'strong', 'em', 'blockquote'],
                ALLOWED_ATTR: [] // no attributes allowed
            });

            // Initialize PDF.js worker
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.PDF.WORKER_SRC;
            }

            // =============================================================================
            // UTILITIES
            // =============================================================================
            const Utils = {
                escapeHtml(s = '') { return String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])) },

                stripHtml(s = '') {
                    const div = document.createElement('div');
                    div.innerHTML = String(s);
                    return (div.textContent || div.innerText || '').trim();
                },

                /**
                 * Get parameter value by index from VA parameters array
                 */
                getParamByIndex(params, index) {
                    return (Array.isArray(params) && params[index]) ? params[index].value : undefined;
                },

                /**
                 * Create query string from object
                 */
                createQueryString(obj) {
                    return new URLSearchParams(obj).toString();
                },

                /**
                 * Log with consistent formatting
                 */
                log(category, message, data = null) {
                    const logMessage = `[${category}] ${message}`;
                    if (data) {
                        console.log(logMessage, data);
                    } else {
                        console.log(logMessage);
                    }
                },

                /**
                 * Clean text for LLM processing
                 */
                cleanTextForLLM(text, options = {}) {
                    const defaults = {
                        removeExtraSpaces: true,
                        removeSpecialChars: true,
                        normalizeWhitespace: true,
                        removeEmptyLines: true,
                        trimLines: true,
                        maxConsecutiveNewlines: 2
                    };

                    const settings = { ...defaults, ...options };

                    let cleaned = text || '';

                    if (settings.removeSpecialChars) {
                        cleaned = cleaned.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '');
                        cleaned = cleaned.replace(/[\u200B-\u200D\uFEFF]/g, '');
                    }

                    if (settings.normalizeWhitespace) {
                        cleaned = cleaned.replace(/[\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]/g, ' ');
                        cleaned = cleaned.replace(/\t/g, ' ');
                    }

                    if (settings.removeExtraSpaces) {
                        cleaned = cleaned.replace(/[^\S\r\n]+/g, ' ');
                    }

                    if (settings.trimLines) {
                        cleaned = cleaned.split('\n').map(line => line.trim()).join('\n');
                    }

                    if (settings.removeEmptyLines) {
                        cleaned = cleaned.split('\n').filter(line => line.length > 0).join('\n');
                    }

                    if (settings.maxConsecutiveNewlines > 0) {
                        const regex = new RegExp(`\\n{${settings.maxConsecutiveNewlines + 1},}`, 'g');
                        const replacement = '\n'.repeat(settings.maxConsecutiveNewlines);
                        cleaned = cleaned.replace(regex, replacement);
                    }

                    return cleaned.trim();
                },

                /**
                 * Format file size for display
                 */
                formatFileSize(bytes) {
                    if (!bytes) return 'Unknown size';
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${sizes[i]}`;
                },

                /**
                 * Get file type display name
                 */
                getFileTypeDisplay(filename) {
                    if (!filename) return 'File';
                    const ext = filename.split('.').pop().toLowerCase();
                    const types = {
                        'pdf': 'PDF',
                        'docx': 'DOCX',
                        'doc': 'DOC',
                        'txt': 'TXT',
                        'text': 'TXT',
                        'csv': 'CSV',
                        'xlsx': 'XLSX',
                        'xls': 'XLS'
                    };
                    return types[ext] || ext.toUpperCase();
                }
            };

            // =============================================================================
            // UI MANAGER
            // =============================================================================
            const UIManager = {
                _allFiles: [],
                _selectedFileId: null,

                /**
                 * Update the main output display
                 */
                updateOutput(message, append = false) {
                    const element = document.getElementById(CONFIG.ELEMENTS.output);
                    if (element) {
                        element.textContent = append ? element.textContent + message : message;
                    }
                },

                /**
                 * Append to the main output display
                 */
                appendOutput(message) {
                    this.updateOutput(`\n${message}`, true);
                },

                /**
                 * Populate the file list with clickable items
                 */
                populateFileList(files) {
                    this._allFiles = files;
                    const listEl = document.getElementById(CONFIG.ELEMENTS.filelist);
                    if (!listEl) return;

                    const currentSelection = this._selectedFileId;

                    if (!files || files.length === 0) {
                        listEl.innerHTML = '<div class="loading-message">No files available</div>';
                        return;
                    }

                    listEl.innerHTML = '';

                    // --- ADD: permanent "All Documents" row ---
                    const allEl = document.createElement('div');
                    allEl.className = 'file all-docs';
                    allEl.dataset.fileId = CONFIG.SPECIAL.ALL_ID;
                    allEl.dataset.fileName = CONFIG.SPECIAL.ALL_NAME.toLowerCase();
                    if (String(currentSelection) === CONFIG.SPECIAL.ALL_ID) allEl.classList.add('is-active');
                    allEl.innerHTML = `
    <div class="name">${CONFIG.SPECIAL.ALL_NAME}</div>
    <div class="meta">${files.length} documents</div>
  `;
                    allEl.addEventListener('click', () => { this.selectFile(CONFIG.SPECIAL.ALL_ID); });
                    listEl.appendChild(allEl);

                    // --- ADD: thin separator line ---
                    const sep = document.createElement('div');
                    sep.className = 'divider';
                    listEl.appendChild(sep);

                    // --- Existing: individual documents ---
                    files.forEach(file => {
                        const id = file.id || file.fileId;
                        const name = file.name || file.fileName || id;
                        const size = file.size || file.fileSize || 0;

                        const fileEl = document.createElement('div');
                        fileEl.className = 'file';
                        fileEl.dataset.fileId = String(id);
                        fileEl.dataset.fileName = name.toLowerCase();

                        if (String(id) === String(currentSelection)) fileEl.classList.add('is-active');

                        fileEl.innerHTML = `
  <div class="main">
    <div class="name">${name}</div>
    <div class="meta">${Utils.getFileTypeDisplay(name)} · ${Utils.formatFileSize(size)}</div>
  </div>
  <div class="actions">
    <button class="icon-btn open-btn" type="button" aria-label="Open content" title="Open content">
      <svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true">
        <path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3zM5 5h6v2H7v10h10v-4h2v6H5V5z"></path>
      </svg>
    </button>
  </div>
`;

                        fileEl.addEventListener('click', () => { this.selectFile(id); });
                        listEl.appendChild(fileEl);

                        // Clicking the tiny icon opens the big modal (and does NOT change selection)
                        const openBtn = fileEl.querySelector('.open-btn');
                        openBtn.addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            App.openContentModal(String(id), String(name));
                        });
                    });

                    // hidden select 
                    this.populateFileDropdown(files);

                    // restore search filter if present
                    const searchInput = document.getElementById(CONFIG.ELEMENTS.searchInput);
                    if (searchInput && searchInput.value) this.filterFiles(searchInput.value);

                    // keep summarize button state fresh
                    window.DocumentSummarizerApp?._updateBtn?.();
                },

                /**
                 * Select a file and update UI
                 */
                selectFile(fileId) {
                    this._selectedFileId = String(fileId);

                    // Update active state
                    document.querySelectorAll('.file').forEach(el => {
                        if (el.dataset.fileId === String(fileId)) {
                            el.classList.add('is-active');
                        } else {
                            el.classList.remove('is-active');
                        }
                    });

                    // Update hidden select
                    const selectEl = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    if (selectEl) {
                        selectEl.value = String(fileId);
                    }

                    // Trigger file loading via the handlers exposed in App.init()
                    if (window.DocumentSummarizerApp?._onFileSelected) {
                        window.DocumentSummarizerApp._onFileSelected(String(fileId));
                    }
                },
                /**
                 * Filter files based on search input
                 */
                filterFiles(searchTerm) {
                    const term = searchTerm.toLowerCase();
                    document.querySelectorAll('.file').forEach(el => {
                        const isAll = el.classList.contains('all-docs');
                        if (isAll) { el.style.display = ''; return; }    // always show "All Documents"
                        const fileName = el.dataset.fileName || '';
                        if (fileName.includes(term)) {
                            el.style.display = '';
                        } else {
                            el.style.display = 'none';
                        }
                    });
                },

                /**
                 * Populate the hidden file dropdown (for compatibility)
                 */
                populateFileDropdown(files) {
                    const selectEl = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    const countEl = document.getElementById(CONFIG.ELEMENTS.fileCount);

                    if (!selectEl || !countEl) return;

                    selectEl.innerHTML = '<option value="">— select a file —</option>';

                    files.forEach(file => {
                        const id = file.id || file.fileId;
                        const name = file.name || file.fileName || id;
                        const option = document.createElement('option');
                        option.value = String(id);
                        option.textContent = name;
                        selectEl.appendChild(option);
                    });

                    const countText = files.length ? `(${files.length} files)` : '(no files)';
                    countEl.textContent = countText;
                    return countText;
                },

                /**
                 * Show error state
                 */
                showError(message) {
                    this.appendOutput(`\nError: ${message}`);
                    const listEl = document.getElementById(CONFIG.ELEMENTS.filelist);
                    if (listEl) {
                        listEl.innerHTML = `<div class="loading-message">Error: ${message}</div>`;
                    }
                },


                /**
                 * Setup event listeners for UI interactions
                 */
                setupEventListeners() {
                    // Search input
                    const searchInput = document.getElementById(CONFIG.ELEMENTS.searchInput);
                    const searchClear = document.getElementById('searchClear');
                    if (searchInput && searchClear) {
                        // Handle input changes
                        searchInput.addEventListener('input', (e) => {
                            const hasValue = e.target.value.length > 0;

                            // Show/hide clear button
                            if (hasValue) {
                                searchClear.classList.add('visible');
                            } else {
                                searchClear.classList.remove('visible');
                            }

                            // Filter files
                            this.filterFiles(e.target.value);
                        });

                        // Handle clear button click
                        searchClear.addEventListener('click', () => {
                            searchInput.value = '';
                            searchClear.classList.remove('visible');
                            this.filterFiles(''); // Reset filter to show all files
                            searchInput.focus(); // Return focus to input
                        });

                        // Also handle keyboard clearing (optional - for ESC key)
                        searchInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape' && e.target.value) {
                                searchInput.value = '';
                                searchClear.classList.remove('visible');
                                this.filterFiles('');
                            }
                        });

                    }

                    // Hidden file select (for compatibility)
                    const fileSelect = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    if (fileSelect) {
                        fileSelect.addEventListener('change', (event) => {
                            const fileId = event.target.value;
                            if (fileId) {
                                Utils.log('UI', `File selected: ${fileId}`);
                                if (window.DocumentSummarizerApp && window.DocumentSummarizerApp._onFileSelected) {
                                    window.DocumentSummarizerApp._onFileSelected(fileId);
                                }
                            } else {
                                // Clear selection so the centralized updater knows no file is selected
                                this._selectedFileId = null;
                                window.DocumentSummarizerApp?._updateBtn?.();
                            }
                        });
                    }

                    // Summarize button
                    const summarizeBtn = document.getElementById(CONFIG.ELEMENTS.summarizeBtn);
                    if (summarizeBtn) {
                        summarizeBtn.addEventListener('click', () => {
                            if (window.DocumentSummarizerApp && window.DocumentSummarizerApp._onSummarizeClick) {
                                window.DocumentSummarizerApp._onSummarizeClick();
                            }
                        });
                    }
                }
            };

            // =============================================================================
            // API SERVICE
            // =============================================================================
            const APIService = {
                // Store token for reuse
                _accessToken: null,

                /**
                 * Get SAS access token using OAuth2 password grant
                 */
                async getSASToken(username, password) {
                    const url = `${CONFIG.SAS_SERVER}${CONFIG.SAS_AUTH.TOKEN_ENDPOINT}`;
                    Utils.log('AUTH', `Getting SAS token from: ${url}`);

                    try {
                        const credentials = btoa(`${CONFIG.SAS_AUTH.CLIENT_ID}:${CONFIG.SAS_AUTH.CLIENT_SECRET}`);

                        const formData = new URLSearchParams({
                            'grant_type': 'password',
                            'username': username,
                            'password': password
                        });

                        const response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Basic ${credentials}`,
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'Accept': 'application/json'
                            },
                            body: formData
                        });

                        if (!response.ok) {
                            throw new Error(`Authentication failed: HTTP ${response.status} ${response.statusText}`);
                        }

                        const data = await response.json();
                        Utils.log('AUTH', 'Token received successfully');

                        this._accessToken = data.access_token;
                        return data.access_token;
                    } catch (error) {
                        Utils.log('AUTH', 'Token request failed', error);
                        throw new Error(`Failed to get SAS token: ${error.message}`);
                    }
                },

                /**
                 * Get current access token (cached or fetch new one)
                 */
                async getAccessToken(username, password) {
                    if (!this._accessToken) {
                        this._accessToken = await this.getSASToken(username, password);
                    }
                    return this._accessToken;
                },

                /**
                 * Clear cached token (useful for re-authentication)
                 */
                clearToken() {
                    this._accessToken = null;
                    Utils.log('AUTH', 'Token cache cleared');
                },

                /**
                 * Fetch files for a given alert ID
                 */
                async fetchAlertFiles(alertId, username = null, password = null) {
                    const url = `${CONFIG.SAS_SERVER}/svi-datahub/documents/alerts/${encodeURIComponent(alertId)}/files`;
                    Utils.log('API', `Fetching files from: ${url}`);
                    UIManager.appendOutput('Fetching files from SAS API...');

                    try {
                        let headers = {
                            'Accept': 'application/json'
                        };

                        if (username && password) {
                            try {
                                const token = await this.getAccessToken(username, password);
                                headers['Authorization'] = `Bearer ${token}`;
                                Utils.log('API', 'Using authenticated request');
                            } catch (authError) {
                                Utils.log('API', 'Authentication failed, trying unauthenticated request', authError);
                                UIManager.appendOutput('\nAuthentication failed, trying without auth...');
                            }
                        }

                        const response = await fetch(url, {
                            method: 'GET',
                            headers: headers
                        });

                        Utils.log('API', `Response status: ${response.status}`);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        Utils.log('API', 'Full response received', data);

                        const files = Array.isArray(data) ? data : (data.items || data.files || []);

                        Utils.log('FILES', `Parsed ${files.length} files`, files[0]);
                        return files;
                    } catch (error) {
                        Utils.log('API', 'Fetch failed', error);
                        throw error;
                    }
                },

                /**
                 * Get raw file content from SAS
                 */
                async getFileContent(alertId, fileId, username, password) {
                    const url = `${CONFIG.SAS_SERVER}/svi-datahub/documents/alerts/${encodeURIComponent(alertId)}/files/${encodeURIComponent(fileId)}/content`;
                    Utils.log('API', `Fetching file content: ${url}`);

                    try {
                        const token = await this.getAccessToken(username, password);

                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const contentType = response.headers.get('Content-Type') || '';
                        Utils.log('API', `File content type: ${contentType}`);

                        const arrayBuffer = await response.arrayBuffer();

                        return {
                            contentType: contentType,
                            arrayBuffer: arrayBuffer
                        };
                    } catch (error) {
                        Utils.log('API', 'File content fetch failed', error);
                        throw error;
                    }
                },

                /**
                 * Extract text from PDF using PDF.js
                 */
                async extractTextFromPDF(arrayBuffer, onProgress = null) {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.js library not loaded');
                    }

                    try {
                        Utils.log('PDF', 'Loading PDF document');
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        const numPages = pdf.numPages;
                        Utils.log('PDF', `PDF has ${numPages} pages`);

                        const textBuilder = [];

                        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                            if (onProgress) {
                                onProgress(`Processing page ${pageNum} of ${numPages}`);
                            }

                            Utils.log('PDF', `Processing page ${pageNum}`);
                            try {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items
                                    .map(item => item.str)
                                    .join(' ')
                                    .trim();

                                if (pageText) {
                                    textBuilder.push(pageText);
                                }

                                page.cleanup();
                            } catch (pageError) {
                                Utils.log('PDF', `Error processing page ${pageNum}`, pageError);
                            }
                        }

                        pdf.destroy();

                        const fullText = textBuilder.join(' ').trim();
                        return fullText || '[No text content could be extracted from this PDF]';
                    } catch (error) {
                        Utils.log('PDF', 'PDF processing failed', error);
                        throw new Error(`PDF text extraction failed: ${error.message}`);
                    }
                },

                /**
                 * Extract text from file based on content type
                 */
                async extractTextFromFile(fileData, onProgress = null) {
                    const { contentType, arrayBuffer } = fileData;

                    try {
                        if (contentType.includes('pdf')) {
                            Utils.log('EXTRACT', 'Processing PDF document');
                            return await this.extractTextFromPDF(arrayBuffer, onProgress);
                        }
                        else if (contentType.includes('wordprocessingml.document') ||
                            contentType.includes('msword') ||
                            contentType.includes('word')) {
                            Utils.log('EXTRACT', 'Processing Word document');
                            if (typeof mammoth !== 'undefined') {
                                if (onProgress) {
                                    onProgress('Extracting text from Word document');
                                }
                                const result = await mammoth.extractRawText({ arrayBuffer });
                                return result.value;
                            } else {
                                return `[WORD DOCUMENT DETECTED]\nContent type: ${contentType}\nFile size: ${arrayBuffer.byteLength} bytes\nMammoth.js not loaded - cannot extract text`;
                            }
                        }
                        else if (contentType.includes('text/plain') || contentType.includes('text/')) {
                            Utils.log('EXTRACT', 'Processing text file');
                            if (onProgress) {
                                onProgress('Reading text file');
                            }
                            const decoder = new TextDecoder('utf-8');
                            return decoder.decode(arrayBuffer);
                        }
                        else {
                            Utils.log('EXTRACT', `Unknown content type: ${contentType}, trying text decode`);
                            if (onProgress) {
                                onProgress('Attempting to read as text file');
                            }
                            const decoder = new TextDecoder('utf-8');
                            return decoder.decode(arrayBuffer);
                        }
                    } catch (error) {
                        Utils.log('EXTRACT', 'Text extraction failed', error);
                        return `[ERROR EXTRACTING TEXT]\nContent type: ${contentType}\nError: ${error.message}\nFile size: ${arrayBuffer.byteLength} bytes`;
                    }
                },

                /**
                 * Call OpenAI API for summarization
                 */
                async callOpenAI(text, apiKey, model = CONFIG.OPENAI.MODEL, onDelta) {
                    const isMulti = text.startsWith('[[MULTI_DOC]]') || text.includes('==== [DOC ');

                    // Character limits based on page estimates
                    const CHARS_PER_PAGE = 2000;
                    const MAX_CHARS_PER_DOC = 20 * CHARS_PER_PAGE;  // 40,000 chars (~20 pages)
                    const MAX_CHARS_TOTAL = 120 * CHARS_PER_PAGE;   // 240,000 chars (~120 pages)

                    // Process multi-document text
                    if (isMulti) {
                        text = this.clipMultiDocuments(text, MAX_CHARS_PER_DOC, MAX_CHARS_TOTAL);
                    } else {
                        // Single document clipping
                        if (text.length > MAX_CHARS_TOTAL) {
                            text = text.slice(0, MAX_CHARS_TOTAL) + '\n[...document trimmed]';
                        }
                    }

                    const singlePrompt = `You are a helpful assistant that creates concise, clear summaries in English.
Rules:
- Length: ≤ 1/4 of the input, and never more than 500 words.
- Output: strict, self-contained HTML5 (no Markdown).
- Use only: <article>, <h2>, <h3>, <p>, <ul>, <ol>, <li>, <strong>, <em>, <blockquote>.
- No <script>, <style>, images, iframes, links or inline events.
Structure:
<article>
  <h2>Title</h2>
  <p>One-sentence gist.</p>
  <h3>Key points</h3>
  <ul><li>…</li></ul>
  <h3>Details</h3>
  <p>…</p>
</article>

Summarize this document:\n\n${text}`;

                    const multiPrompt = `You are a helpful assistant that summarizes a set of documents (marked by "==== [DOC n] <name> ====").
Rules:
- One cohesive HTML5 summary for ALL documents, ≤ 800 words total.
- Output: strict HTML5; allowed: <article>, <h2>, <h3>, <p>, <ul>, <ol>, <li>, <strong>, <em>, <blockquote>.
- Deduplicate, merge overlaps, note contradictions. No quotes/links.

Structure:
<article>
  <h2>Overall summary</h2>
  <p>1–2 sentence gist across all docs.</p>
  <h3>Key themes</h3>
  <ul><li>Theme — short rationale</li></ul>
  <h3>Per-document highlights</h3>
  <ul>
    <li><strong>DOC 1 — <em>name</em>:</strong> Most unique point from this document</li>
    <li><strong>DOC 2 — <em>name</em>:</strong> Most unique point from this document</li>
    <!-- one <li> per document -->
  </ul>
  <h3>Risks / disagreements</h3>
  <ul><li>…if any…</li></ul>
</article>

Summarize the set:\n\n${text}`;

                    const systemPrompt = isMulti ? multiPrompt : singlePrompt;

                    const body = {
                        model,
                        input: systemPrompt,
                        reasoning: { effort: "low" },
                        text: { verbosity: "low" },
                        stream: !!onDelta
                    };
                    const res = await fetch(CONFIG.OPENAI.URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'Accept': onDelta ? 'text/event-stream' : 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    // Non-streaming path
                    if (!onDelta) {
                        const json = await res.json().catch(() => ({}));
                        if (!res.ok) throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                        const txt = (json.output_text ?? json.choices?.[0]?.message?.content ?? '');
                        if (!txt) throw new Error('LLM returned no text payload');
                        return txt;
                    }

                    // Streaming path (SSE)
                    if (!res.ok || !res.body) {
                        const text = await res.text().catch(() => '');
                        throw new Error(`${res.status} ${res.statusText}\n${text.slice(0, 500)}`);
                    }

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let carry = '';
                    let full = '';

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        carry += decoder.decode(value, { stream: true });

                        const frames = carry.split('\n\n');
                        carry = frames.pop() || '';

                        for (const frame of frames) {
                            const dataLines = frame
                                .split('\n')
                                .filter(l => l.startsWith('data:'))
                                .map(l => l.slice(5).trim())
                                .join('\n');

                            if (!dataLines || dataLines === '[DONE]') continue;

                            let evt;
                            try {
                                evt = JSON.parse(dataLines);
                            } catch {
                                continue;
                            }

                            if (evt.type === 'response.output_text.delta') {
                                const delta = evt.delta || '';
                                if (delta) {
                                    full += delta;
                                    try {
                                        onDelta(delta, full, evt);
                                    } catch {
                                        /* ignore handler errors */
                                    }
                                }
                            } else if (evt.type === 'error') {
                                throw new Error(evt.error?.message || 'Streaming error');
                            }
                        }
                    }

                    return full.trim();
                },
                /**
                 * Call OpenAI for document-grounded Q&A (no summary system prompt)
                 */
                async callOpenAIChat(prompt, apiKey, model = CONFIG.OPENAI.MODEL, onDelta) {
                    const body = {
                        model,
                        input: prompt,                 // <-- use the prompt exactly as built by Chat.buildPrompt
                        reasoning: { effort: "low" },
                        text: { verbosity: "low" },
                        stream: !!onDelta
                    };

                    const res = await fetch(CONFIG.OPENAI.URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'Accept': onDelta ? 'text/event-stream' : 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    // Non-streaming path
                    if (!onDelta) {
                        const json = await res.json().catch(() => ({}));
                        if (!res.ok) throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                        const txt = (json.output_text ?? json.choices?.[0]?.message?.content ?? '');
                        if (!txt) throw new Error('LLM returned no text payload');
                        return txt;
                    }

                    // Streaming path (SSE)
                    if (!res.ok || !res.body) {
                        const text = await res.text().catch(() => '');
                        throw new Error(`${res.status} ${res.statusText}\n${text.slice(0, 500)}`);
                    }

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let carry = '';
                    let full = '';

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        carry += decoder.decode(value, { stream: true });

                        const frames = carry.split('\n\n');
                        carry = frames.pop() || '';

                        for (const frame of frames) {
                            const dataLines = frame
                                .split('\n')
                                .filter(l => l.startsWith('data:'))
                                .map(l => l.slice(5).trim())
                                .join('\n');

                            if (!dataLines || dataLines === '[DONE]') continue;

                            let evt;
                            try {
                                evt = JSON.parse(dataLines);
                            } catch {
                                continue;
                            }

                            if (evt.type === 'response.output_text.delta') {
                                const delta = evt.delta || '';
                                if (delta) {
                                    full += delta;
                                    try { onDelta(delta, full, evt); } catch { }
                                }
                            } else if (evt.type === 'error') {
                                throw new Error(evt.error?.message || 'Streaming error');
                            }
                        }
                    }

                    return full.trim();
                },

                /**
                 * Clip individual documents and total concatenation for multi-doc summaries
                 */
                clipMultiDocuments(text, maxPerDoc, maxTotal) {
                    // Parse documents - first collect all matches
                    const docPattern = /==== \[DOC (\d+)\] (.*?) ====/g;
                    const matches = [];
                    let match;

                    // Collect all document headers first
                    while ((match = docPattern.exec(text)) !== null) {
                        matches.push({
                            index: match.index,
                            num: match[1],
                            name: match[2],
                            header: match[0]
                        });
                    }

                    // Extract preamble
                    const preamble = matches.length > 0 ? text.slice(0, matches[0].index) : '';

                    // Extract document contents
                    const documents = matches.map((match, i) => {
                        const docStart = match.index + match.header.length;
                        const docEnd = i < matches.length - 1 ? matches[i + 1].index : text.length;
                        const content = text.slice(docStart, docEnd).trim();

                        return {
                            num: match.num,
                            name: match.name,
                            header: match.header,
                            content: content,
                            originalLength: content.length
                        };
                    });

                    // Clip individual documents if needed
                    let totalChars = preamble.length;
                    const clippedDocs = documents.map(doc => {
                        let content = doc.content;
                        if (content.length > maxPerDoc) {
                            // Try to clip at a sentence boundary
                            const clipPoint = this.findSentenceBoundary(content, maxPerDoc);
                            content = content.slice(0, clipPoint) + '\n[...document trimmed from ' +
                                Math.round(doc.originalLength / 1000) + 'k to ' +
                                Math.round(clipPoint / 1000) + 'k chars]';
                        }

                        totalChars += doc.header.length + content.length + 2; // +2 for newlines

                        return {
                            ...doc,
                            content: content,
                            clipped: content.length < doc.originalLength
                        };
                    });

                    // If still too long, proportionally reduce all documents
                    if (totalChars > maxTotal) {
                        const reductionRatio = (maxTotal - preamble.length) / (totalChars - preamble.length);

                        return preamble + clippedDocs.map(doc => {
                            const targetLength = Math.floor(doc.content.length * reductionRatio * 0.9); // 0.9 for safety margin
                            const clipPoint = this.findSentenceBoundary(doc.content, targetLength);
                            const clippedContent = doc.content.slice(0, clipPoint);

                            return doc.header + '\n' + clippedContent +
                                '\n[...trimmed to fit total limit]';
                        }).join('\n\n');
                    }

                    // Reconstruct text
                    return preamble + clippedDocs.map(doc =>
                        doc.header + '\n' + doc.content
                    ).join('\n\n');
                },
                /**
                 * Find a good sentence boundary near the target length
                 */
                findSentenceBoundary(text, targetLength) {
                    if (text.length <= targetLength) return text.length;

                    // Look for sentence end within 200 chars before target
                    const searchStart = Math.max(0, targetLength - 200);
                    const searchText = text.slice(searchStart, targetLength);

                    // Find last sentence ending
                    const sentenceEnds = ['. ', '.\n', '! ', '!\n', '? ', '?\n'];
                    let lastEnd = -1;
                    let endChar = '';

                    for (const end of sentenceEnds) {
                        const pos = searchText.lastIndexOf(end);
                        if (pos > lastEnd) {
                            lastEnd = pos;
                            endChar = end;
                        }
                    }

                    if (lastEnd > -1) {
                        return searchStart + lastEnd + endChar.length;
                    }

                    // No sentence boundary found, look for paragraph break
                    const lastNewline = searchText.lastIndexOf('\n');
                    if (lastNewline > -1) {
                        return searchStart + lastNewline + 1;
                    }

                    // Fall back to word boundary
                    const lastSpace = searchText.lastIndexOf(' ');
                    if (lastSpace > -1) {
                        return searchStart + lastSpace + 1;
                    }

                    // Last resort: hard cut
                    return targetLength;
                }
            };



            // =============================================================================
            // VA INTEGRATION
            // =============================================================================
            const VAIntegration = {
                /**
                 * Extract parameters from VA message object
                 */
                extractParameters(vaMsgObj) {
                    const params = vaMsgObj?.parameters || [];
                    const indexes = CONFIG.PARAMETER_INDEXES;

                    return {
                        alertId: Utils.getParamByIndex(params, indexes.alertId),
                        openaiKey: Utils.getParamByIndex(params, indexes.openaiKey),
                        sasUser: Utils.getParamByIndex(params, indexes.sasUser),
                        sasPass: Utils.getParamByIndex(params, indexes.sasPass)
                    };
                },

                /**
                 * Handle incoming VA parameters
                 */
                async handleVAMessage(vaMsgObj) {
                    const params = this.extractParameters(vaMsgObj);

                    Utils.log('VA', 'Parameters received', {
                        alertId: params.alertId,
                        hasOpenAI: !!params.openaiKey,
                        sasUser: params.sasUser,
                        hasPass: !!params.sasPass
                    });

                    const paramStatus = [
                        `Alert ID: ${params.alertId || 'missing'}`,
                        `OpenAI Key: ${params.openaiKey ? 'present' : 'missing'}`,
                        `SAS User: ${params.sasUser || 'missing'}`,
                        `SAS Pass: ${params.sasPass ? 'present' : 'missing'}`
                    ].join('\n');

                    UIManager.updateOutput(`Received parameters:\n${paramStatus}`);

                    App.setCurrentParams(params);

                    if (params.alertId && params.openaiKey && params.sasUser && params.sasPass) {
                        try {
                            const files = await APIService.fetchAlertFiles(
                                params.alertId,
                                params.sasUser,
                                params.sasPass
                            );

                            UIManager.populateFileList(files);
                            UIManager.appendOutput(`\nAPI Response: (${files.length} files)`);
                            App.preloadFirstFiles(files);

                            App.startAutoRefresh();
                        } catch (error) {
                            UIManager.showError(error.message);
                        }
                    } else {
                        UIManager.appendOutput('\nMissing required parameters - cannot fetch files');
                        App.stopAutoRefresh();
                    }
                },

                /**
                 * Initialize VA integration with retry logic
                 */
                initialize() {
                    const tryConnect = () => {
                        if (window.va && va.messagingUtil && typeof va.messagingUtil.setOnDataReceivedCallback === 'function') {
                            va.messagingUtil.setOnDataReceivedCallback(this.handleVAMessage.bind(this));
                            Utils.log('VA', 'Listener attached successfully');
                            UIManager.updateOutput('VA listener attached, waiting for data...');
                        } else {
                            Utils.log('VA', 'Not ready, retrying...');
                            UIManager.updateOutput('VA not ready, retrying...');
                            setTimeout(tryConnect, CONFIG.VA_RETRY_INTERVAL);
                        }
                    };

                    tryConnect();
                }
            };

            // =============================================================================
            // CHAT (document-grounded Q&A)
            // =============================================================================
            const Chat = {
                _busy: false,
                els: {},

                // per-document chat threads 
                _threads: new Map(),           // key -> [{ role: 'user'|'bot', html: string, plain?: string }]
                _lastBotNodeByKey: new Map(),  // key -> DOM node of last bot bubble (for streaming)

                currentKey() {
                    const a = App._currentParams?.alertId ?? 'GLOBAL';
                    const f = App.getSelectedFileId?.() ?? null;
                    return f ? `${a}:${f}` : null;
                },

                renderThread(key = this.currentKey()) {
                    if (!this.els.msgs) return;
                    this.els.msgs.innerHTML = '';
                    if (!key) return;

                    let arr = this._threads.get(key);
                    if (!arr) {
                        // seed a per-doc welcome message
                        arr = [{ role: 'bot', html: "Hi! Ask me anything about the currently selected document." }];
                        this._threads.set(key, arr);
                    }
                    for (const m of arr) this.addMsg(m.role, m.html);
                    this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                },

                appendToThread(role, html, key = this.currentKey(), plain = '') {
                    if (!key) return;
                    const arr = this._threads.get(key) ?? [];
                    arr.push({ role, html, plain });
                    this._threads.set(key, arr);
                },

                init() {
                    this.els = {
                        toggle: document.getElementById(CONFIG.ELEMENTS.viewToggle),
                        card: document.querySelector('.card'),
                        input: document.getElementById(CONFIG.ELEMENTS.chatText),
                        send: document.getElementById(CONFIG.ELEMENTS.chatSendBtn),
                        msgs: document.getElementById(CONFIG.ELEMENTS.chatMessages),
                        title: document.getElementById('title'),
                        subtitle: document.querySelector('.subtitle')
                    };

                    this.setHeader = (showChat) => {
                        const h = CONFIG.HEADINGS[showChat ? 'chat' : 'summary'];
                        if (this.els.title) this.els.title.textContent = h.title;
                        if (this.els.subtitle) this.els.subtitle.textContent = h.subtitle;
                        document.title = h.title; // optional: page <title>
                    };

                    this.refreshSend();

                    this.setHeader(this.els.card.classList.contains('show-chat'));
                    if (this.els.card.classList.contains('show-chat')) {
                        this.renderThread(this.currentKey());
                    }


                    // Events
                    this.els.send.addEventListener('click', () => this.handleSend());
                    this.els.input.addEventListener('input', () => this.refreshSend());
                    this.els.input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.handleSend(); } });

                    // Toggle Summary <-> Chat
                    this.els.toggle.addEventListener('click', () => {
                        const showChat = !this.els.card.classList.contains('show-chat');
                        this.els.card.classList.toggle('show-chat', showChat);
                        this.els.toggle.setAttribute('aria-checked', showChat ? 'true' : 'false');
                        this.setHeader(showChat);
                        if (showChat) this.renderThread(this.currentKey());

                    });
                },

                refreshSend() {
                    const hasKey = !!App._currentParams?.openaiKey;
                    const hasDoc = !!App._currentCleanedText;
                    const hasText = (this.els.input?.value.trim().length > 0);
                    if (this.els.send) this.els.send.disabled = this._busy || !(hasKey && hasDoc && hasText);
                },

                addMsg(role, html) {
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    bubble.innerHTML = html;
                    wrap.appendChild(bubble);
                    this.els.msgs.appendChild(wrap);
                    this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                    return bubble;
                },

                thinking() {
                    const bubble = this.addMsg('bot', '<span class="typing">Thinking<span class="dots"><i></i><i></i><i></i></span></span>');
                    return { bubble, stop: () => { bubble.parentElement?.remove(); } };
                },

                buildPrompt(userText, docText) {
                    let processedText = docText || '';
                    const isMulti = processedText.startsWith('[[MULTI_DOC]]') || processedText.includes('==== [DOC ');

                    if (isMulti) {
                        const CHARS_PER_DOC_CHAT = 5000, MAX_CHARS_CHAT = 50000;
                        processedText = APIService.clipMultiDocuments(processedText, CHARS_PER_DOC_CHAT, MAX_CHARS_CHAT);
                    } else {
                        const MAX_SINGLE_DOC_CHAT = 24000;
                        if (processedText.length > MAX_SINGLE_DOC_CHAT) {
                            const clipPoint = APIService.findSentenceBoundary(processedText, MAX_SINGLE_DOC_CHAT);
                            processedText = processedText.slice(0, clipPoint) + '\n[...document trimmed for chat context]';
                        }
                    }

                    const cleaned = Utils.cleanTextForLLM(processedText, { maxConsecutiveNewlines: 2 });
                    const history = this.buildHistoryBlock(this.currentKey(), 3);

                    return [
                        "SYSTEM:",
                        "You are a concise assistant answering questions ONLY using the provided Document content.",
                        "Use the Conversation Context only for continuity; if context conflicts with the Document, the Document wins.",
                        "If the answer is not in the Document, say so plainly. Keep answers brief and clear.",
                        "",
                        history ? history : "",
                        history ? "" : "",           // keep spacing consistent
                        "DOCUMENT:",
                        cleaned,
                        "",
                        "USER QUESTION:",
                        userText,
                        "",
                        "ASSISTANT:"
                    ].join("\n");
                },

                async handleSend() {
                    const text = this.els.input.value.trim();
                    if (!text) return;

                    const key = this.currentKey();

                    // user message (preserve line breaks)
                    const userHtml = Utils.escapeHtml(text).replace(/\n/g, '<br>');
                    this.addMsg('user', userHtml);
                    this.appendToThread('user', userHtml, key, text);

                    this.els.input.value = '';
                    this._busy = true; this.refreshSend();

                    // show typing bubble and REUSE it for streaming
                    const think = this.thinking();
                    await new Promise(r => requestAnimationFrame(r));

                    let buf = '';
                    let raf = null;
                    let final = ''; // make visible to finally

                    // thread slot for the bot reply
                    this.appendToThread('bot', '', key, '');
                    const botIdx = this._threads.get(key).length - 1;

                    // stream into the typing bubble
                    const botBubble = think.bubble;
                    const flush = () => {
                        const safe = Utils.escapeHtml(buf).replace(/\n/g, '<br>');
                        botBubble.innerHTML = safe;
                        const arr = this._threads.get(key);
                        if (arr && arr[botIdx]) {
                            arr[botIdx].html = safe;
                            arr[botIdx].plain = buf; // <-- capture plain text too
                        }
                        raf = null;
                        this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                    };
                    try {
                        const params = App._currentParams || {};
                        if (!params.openaiKey) throw new Error('Missing OpenAI key');
                        if (!App._currentCleanedText) throw new Error('Select a file first; no document loaded');

                        const prompt = this.buildPrompt(text, App._currentCleanedText);
                        final = await APIService.callOpenAIChat(
                            prompt, params.openaiKey, CONFIG.OPENAI.MODEL,
                            (_d, full) => { buf = full; if (!raf) raf = requestAnimationFrame(flush); }
                        );

                        if (raf) { cancelAnimationFrame(raf); raf = null; }
                        if (!buf.trim()) { buf = final; flush(); } // non-stream edge case
                    } catch (e) {
                        // show error in the same bubble and in the thread
                        buf = `Sorry, I couldn't complete that: ${e.message}`;
                        flush();
                        console.error('[chat]', e);
                    } finally {
                        this._busy = false; this.refreshSend();
                    }
                },
                buildHistoryBlock(key = this.currentKey(), maxPairs = 3) {
                    const arr = this._threads.get(key) || [];
                    if (!arr.length) return '';

                    // Drop the ephemeral empty bot bubble and the newest user message
                    const filtered = arr.filter((m, i) => !(m.role === 'bot' && !m.html))
                        .slice(); // shallow copy
                    if (filtered.length && filtered[filtered.length - 1].role === 'user') {
                        filtered.pop();
                    }

                    // Walk backward collecting user->bot pairs
                    const pairs = [];
                    for (let i = filtered.length - 1; i >= 1 && pairs.length < maxPairs; i--) {
                        const b = filtered[i], u = filtered[i - 1];
                        if (b.role === 'bot' && u.role === 'user') {
                            pairs.unshift({
                                uq: u.plain || DocumentSummarizerApp._modules.Utils.stripHtml(u.html),
                                ar: b.plain || DocumentSummarizerApp._modules.Utils.stripHtml(b.html)
                            });
                            i--; // skip the user we just consumed
                        }
                    }

                    if (!pairs.length) return '';

                    let out = `CONVERSATION CONTEXT (last ${pairs.length} Q/A turns):\n`;
                    pairs.forEach((p, idx) => {
                        out += `Q${idx + 1}: ${p.uq}\nA${idx + 1}: ${p.ar}\n`;
                    });
                    return out.trim();
                }
            };

            // =============================================================================
            // MAIN APPLICATION
            // =============================================================================
            const App = {
                // Store current parameters for file operations
                _currentParams: null,
                _fileCache: new Map(),
                _summaryCache: new Map(),
                _currentCleanedText: null,
                _refreshInterval: null,
                _inflightLoads: new Set(),   // de-dupe concurrent loads
                _preloadToken: null,         // lets us abort an older preload wave
                _activeSummaries: new Set(), // set of "<alertId>:<fileId>" currently summarizing

                /**
                 * Initialize the entire application
                 */
                init() {
                    Utils.log('APP', 'Initializing Document Summarizer App');

                    try {
                        if (typeof pdfjsLib !== 'undefined') {
                            Utils.log('APP', 'PDF.js loaded successfully');
                        } else {
                            Utils.log('APP', 'Warning: PDF.js not loaded - PDF support will be limited');
                        }

                        UIManager.setupEventListeners();
                        VAIntegration.initialize();
                        Chat.init();

                        window.DocumentSummarizerApp = window.DocumentSummarizerApp || {};
                        window.DocumentSummarizerApp._onFileSelected = this.handleFileSelection.bind(this);
                        window.DocumentSummarizerApp._onSummarizeClick = this.handleSummarize.bind(this);

                        window.DocumentSummarizerApp._updateBtn =
                            this._updateSummarizeButtonForCurrentSelection.bind(this);

                        // Add cleanup on page unload
                        window.addEventListener('beforeunload', () => {
                            this.stopAutoRefresh();
                            APIService.clearToken();
                            Utils.log('APP', 'Cleanup completed on page unload');
                        });

                    } catch (error) {
                        Utils.log('APP', 'Initialization error', error);
                        UIManager.updateOutput(`Error: ${error.message}`);
                    }
                },

                async openContentModal(fileId, fileName = 'Document') {
                    try {
                        const { alertId, sasUser, sasPass } = this._currentParams || {};
                        if (!alertId || !sasUser || !sasPass) {
                            this._currentCleanedText = null;
                            this._updateSummarizeButtonForCurrentSelection();
                            return; // bail gracefully
                        }
                        const modal = document.getElementById('contentModal');
                        const pre = document.getElementById('modalFileContent');
                        const title = document.getElementById('contentModalTitle');

                        if (!modal || !pre) return;

                        // Title
                        if (title) title.textContent = fileName;

                        // Resolve content (single doc or "All Documents")
                        let text = '';
                        if (String(fileId) === DocumentSummarizerApp._modules.CONFIG.SPECIAL.ALL_ID) {
                            // Reuse the same combined builder as handleFileSelection does
                            const parts = [];
                            for (const f of UIManager._allFiles) {
                                const fid = String(f.id || f.fileId || '');
                                if (!fid) continue;
                                const key = `${String(alertId)}:${fid}`;
                                if (this._fileCache.has(key)) {
                                    parts.push(this._fileCache.get(key));
                                } else {
                                    const fd = await DocumentSummarizerApp._modules.APIService.getFileContent(alertId, fid, sasUser, sasPass);
                                    const ex = await DocumentSummarizerApp._modules.APIService.extractTextFromFile(fd);
                                    const cl = DocumentSummarizerApp._modules.Utils.cleanTextForLLM(ex, { maxConsecutiveNewlines: 2 });
                                    this._fileCache.set(key, cl);
                                    parts.push(cl);
                                }
                            }
                            text = parts.join('\n\n');
                        } else {
                            const cacheKey = `${String(alertId)}:${String(fileId)}`;
                            if (this._fileCache.has(cacheKey)) {
                                text = this._fileCache.get(cacheKey);
                            } else {
                                const fileData = await DocumentSummarizerApp._modules.APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                                const extracted = await DocumentSummarizerApp._modules.APIService.extractTextFromFile(fileData);
                                text = DocumentSummarizerApp._modules.Utils.cleanTextForLLM(extracted, { maxConsecutiveNewlines: 2 });
                                this._fileCache.set(cacheKey, text);
                                if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);
                            }
                        }

                        pre.textContent = text || '[No text content]';

                        // Show modal
                        modal.hidden = false;
                        document.body.classList.add('modal-open');

                        // Wire close handlers (once)
                        if (!this._modalWired) {
                            this._modalWired = true;
                            modal.addEventListener('click', (e) => {
                                if (e.target?.dataset?.close === 'true') this.closeContentModal();
                            });
                            const closeBtn = document.getElementById('contentModalClose');
                            if (closeBtn) closeBtn.addEventListener('click', () => this.closeContentModal());
                            window.addEventListener('keydown', (e) => {
                                if (e.key === 'Escape' && !modal.hidden) this.closeContentModal();
                            });
                        }
                    } catch (err) {
                        console.error('[modal] open failed', err);
                        const pre = document.getElementById('modalFileContent');
                        if (pre) pre.textContent = `Error loading content: ${err.message}`;
                        const modal = document.getElementById('contentModal');
                        if (modal) { modal.hidden = false; document.body.classList.add('modal-open'); }
                    }
                },

                closeContentModal() {
                    const modal = document.getElementById('contentModal');
                    if (modal) modal.hidden = true;
                    document.body.classList.remove('modal-open');
                },

                _key(alertId, fileId) {
                    return `${String(alertId ?? 'GLOBAL')}:${String(fileId ?? '')}`;
                },

                _updateSummarizeButtonForCurrentSelection() {
                    const btn = document.getElementById(CONFIG.ELEMENTS.summarizeBtn);
                    if (!btn) return;

                    const fileId = this.getSelectedFileId();
                    const alertId = this._currentParams?.alertId;

                    const isSummarizingThisFile =
                        !!fileId && !!alertId && this._activeSummaries.has(this._key(alertId, fileId));

                    const canSummarizeThisFile =
                        !!this._currentCleanedText && !!this._currentParams?.openaiKey && !!fileId;

                    // Drive the button purely from the *current file* state
                    btn.disabled = !canSummarizeThisFile || isSummarizingThisFile;
                    btn.classList.toggle('loading', isSummarizingThisFile);
                    btn.setAttribute('aria-busy', isSummarizingThisFile ? 'true' : 'false');

                    // keep the documents list in sync (show flowing fade on items being summarized)
                    if (alertId) {
                        document.querySelectorAll('.file').forEach(el => {
                            const fid = el.dataset.fileId;
                            const summarizing = this._activeSummaries.has(this._key(alertId, fid));
                            el.classList.toggle('is-summarizing', summarizing);
                        });
                    }
                },

                startAutoRefresh() {
                    if (!CONFIG.AUTO_REFRESH.ENABLED || this._refreshInterval) return;

                    this._refreshInterval = setInterval(async () => {
                        if (!this._currentParams) return;

                        const { alertId, sasUser, sasPass } = this._currentParams;

                        if (alertId && sasUser && sasPass) {
                            try {
                                Utils.log('AUTO_REFRESH', 'Fetching updated file list');

                                const files = await APIService.fetchAlertFiles(
                                    alertId,
                                    sasUser,
                                    sasPass
                                );

                                // Update file list while preserving selection
                                UIManager.populateFileList(files);

                                Utils.log('AUTO_REFRESH', `Updated file list: ${files.length} files`);
                            } catch (error) {
                                Utils.log('AUTO_REFRESH', 'Refresh failed', error);
                                // Don't show error to user on auto-refresh failures
                            }
                        }
                    }, CONFIG.AUTO_REFRESH.INTERVAL);

                    Utils.log('AUTO_REFRESH', `Started auto-refresh every ${CONFIG.AUTO_REFRESH.INTERVAL}ms`);
                },

                stopAutoRefresh() {
                    if (this._refreshInterval) {
                        clearInterval(this._refreshInterval);
                        this._refreshInterval = null;
                        Utils.log('AUTO_REFRESH', 'Stopped auto-refresh');
                    }
                },

                async preloadFirstFiles(files) {
                    if (!CONFIG.PRELOAD.ENABLED) return;
                    if (!this._currentParams) return;

                    const { alertId, sasUser, sasPass } = this._currentParams;
                    if (!alertId || !sasUser || !sasPass) return;

                    const list = (files && files.length ? files : UIManager._allFiles) || [];
                    if (!list.length) return;

                    const token = Symbol('preload');
                    this._preloadToken = token;

                    const toPreload = list.slice(0, CONFIG.PRELOAD.COUNT);

                    for (const f of toPreload) {
                        // Abort if a newer preload started (e.g., alert switched / list refreshed)
                        if (this._preloadToken !== token) {
                            Utils.log('PRELOAD', 'Aborted previous preload wave');
                            return;
                        }

                        const fileId = String(f.id || f.fileId || '');
                        if (!fileId) continue;

                        const cacheKey = `${String(alertId)}:${fileId}`;

                        // Skip if already cached or currently being fetched
                        if (this._fileCache.has(cacheKey) || this._inflightLoads.has(cacheKey)) {
                            continue;
                        }

                        try {
                            this._inflightLoads.add(cacheKey);

                            // Fetch & extract, same pipeline as handleFileSelection (but no UI updates)
                            const fileData = await APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                            const extracted = await APIService.extractTextFromFile(fileData);
                            const cleaned = Utils.cleanTextForLLM(extracted, {
                                removeExtraSpaces: true,
                                removeSpecialChars: true,
                                normalizeWhitespace: true,
                                removeEmptyLines: true,
                                trimLines: true,
                                maxConsecutiveNewlines: 2
                            });

                            // Put into cache (respect your existing size limit logic)
                            this._fileCache.set(cacheKey, cleaned);
                            if (this._fileCache.size > 10) {
                                const firstKey = this._fileCache.keys().next().value;
                                this._fileCache.delete(firstKey);
                            }

                            Utils.log('PRELOAD', `Cached file ${fileId}`);
                        } catch (e) {
                            Utils.log('PRELOAD', `Failed to preload ${fileId}`, e);
                            // swallow — preloading must be silent
                        } finally {
                            this._inflightLoads.delete(cacheKey);
                        }

                        // Small gap between requests (optional)
                        if (CONFIG.PRELOAD.DELAY) {
                            await new Promise(r => setTimeout(r, CONFIG.PRELOAD.DELAY));
                        }
                    }

                    Utils.log('PRELOAD', 'Preload finished');
                },

                /**
                 * Store current parameters for later use
                 */
                setCurrentParams(params) {
                    this._currentParams = params;
                },

                /**
                 * Handle file selection from dropdown
                 */
                async handleFileSelection(fileId) {
                    const { alertId, sasUser, sasPass } = this._currentParams;

                    this._currentCleanedText = null;
                    this._updateSummarizeButtonForCurrentSelection();

                    // keep cached summary display logic (unchanged) ...
                    const baseKey = `${String(alertId)}:${String(fileId)}:`;
                    const summaryEl = document.getElementById(CONFIG.ELEMENTS.summaryContent);
                    if (this._summaryCache) {
                        const matchKey = [...this._summaryCache.keys()].find(k => k.startsWith(baseKey));
                        if (matchKey && summaryEl) { summaryEl.innerHTML = SANITIZE(this._summaryCache.get(matchKey)); }
                        else if (summaryEl) { summaryEl.innerHTML = '<span style="color: var(--muted)">AI summary will appear here...</span>'; }
                    }

                    try {
                        // === ADD: special "All Documents" concatenation path ===
                        if (String(fileId) === CONFIG.SPECIAL.ALL_ID) {


                            const parts = [];
                            for (const f of UIManager._allFiles) {
                                const fid = String(f.id || f.fileId || '');
                                if (!fid) continue;
                                const cacheKey = `${alertId}:${fid}`;

                                let cleaned;
                                if (this._fileCache.has(cacheKey)) {
                                    cleaned = this._fileCache.get(cacheKey);
                                } else {
                                    const fileData = await APIService.getFileContent(alertId, fid, sasUser, sasPass);
                                    const extracted = await APIService.extractTextFromFile(fileData);
                                    cleaned = Utils.cleanTextForLLM(extracted, {
                                        removeExtraSpaces: true, removeSpecialChars: true, normalizeWhitespace: true,
                                        removeEmptyLines: true, trimLines: true, maxConsecutiveNewlines: 2
                                    });
                                    this._fileCache.set(cacheKey, cleaned);
                                    if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);
                                }

                                // Append content; keep it simple: just a blank line between docs
                                if (cleaned) parts.push(cleaned);
                            }

                            // add a header + per-doc delimiters the LLM can detect
                            const lines = UIManager._allFiles.map((f, i) => {
                                const name = (f.name || f.fileName || f.id || `Document ${i + 1}`).toString();
                                return `- [DOC ${i + 1}] ${name}`;
                            });
                            const combined = [
                                '[[MULTI_DOC]]',                         // <— marker the LLM can key on
                                'INPUT CONTAINS MULTIPLE DOCUMENTS',
                                'TABLE OF CONTENTS:',
                                ...lines,
                                '',                                      // blank line
                                ...UIManager._allFiles.map((f, i) => {
                                    const name = (f.name || f.fileName || f.id || `Document ${i + 1}`).toString();
                                    const fid = String(f.id || f.fileId || '');
                                    const cacheKey = `${alertId}:${fid}`;
                                    const text = this._fileCache.get(cacheKey) || ''; // already filled above
                                    return `==== [DOC ${i + 1}] ${name} ====\n${text}`;
                                })
                            ].join('\n');

                            this._currentCleanedText = combined;
                            this._updateSummarizeButtonForCurrentSelection();

                            if (document.querySelector('.card')?.classList.contains('show-chat')) {
                                Chat.renderThread(Chat.currentKey());  //  swap chat to this doc's thread
                            }
                            Chat.refreshSend();
                            return; // IMPORTANT: stop here; skip single-file path
                        }
                        // === END ADD ===

                        // --- existing single-file path (unchanged) ---
                        const cacheKey = `${alertId}:${fileId}`;
                        if (this._fileCache && this._fileCache.has(cacheKey)) {
                            this._currentCleanedText = this._fileCache.get(cacheKey);
                            this._updateSummarizeButtonForCurrentSelection();
                            if (document.querySelector('.card')?.classList.contains('show-chat')) {
                                Chat.renderThread(Chat.currentKey());
                            }
                            Chat.refreshSend();
                            return;
                        }

                        const fileData = await APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                        const extractedText = await APIService.extractTextFromFile(fileData, (status) => {
                        });
                        const cleanedText = Utils.cleanTextForLLM(extractedText, {
                            removeExtraSpaces: true, removeSpecialChars: true, normalizeWhitespace: true,
                            removeEmptyLines: true, trimLines: true, maxConsecutiveNewlines: 2
                        });

                        this._fileCache.set(cacheKey, cleanedText);
                        if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);

                        this._currentCleanedText = cleanedText;
                        this._updateSummarizeButtonForCurrentSelection();
                        if (document.querySelector('.card')?.classList.contains('show-chat')) {
                            Chat.renderThread(Chat.currentKey());
                        }
                        Chat.refreshSend();

                    } catch (error) {
                        Utils.log('APP', 'File loading failed', error);
                        this._currentCleanedText = null;
                        this._updateSummarizeButtonForCurrentSelection();
                    }
                },


                /**
                 * Get selected file ID from dropdown
                 */
                getSelectedFileId() {
                    // Single source of truth from UIManager
                    return UIManager._selectedFileId || null;
                },
                /**
                 * Handle summarize button click
                 */
                async handleSummarize() {
                    // Allow parallel, but only one per file
                    if (!this._currentCleanedText) {
                        alert('No document content to summarize');
                        return;
                    }
                    if (!this._currentParams || !this._currentParams.openaiKey) {
                        alert('OpenAI API key is required for summarization');
                        return;
                    }

                    const fileId = String(this.getSelectedFileId() ?? '');
                    if (!fileId) {
                        alert('No file selected');
                        return;
                    }
                    const alertId = String(this._currentParams?.alertId ?? 'GLOBAL');
                    const key = this._key(alertId, fileId);

                    // Build cache key first and return early on cache hit (NO activeSummaries change)
                    const fp = String(this._currentCleanedText.length);
                    const summaryCacheKey = `${alertId}:${fileId}:${fp}`;
                    const summaryEl = document.getElementById(CONFIG.ELEMENTS.summaryContent);

                    if (this._summaryCache.has(summaryCacheKey)) {
                        const cachedSummary = this._summaryCache.get(summaryCacheKey);
                        if (summaryEl) summaryEl.innerHTML = SANITIZE(cachedSummary);
                        Utils.log('APP', 'Using cached summary');
                        return;
                    }

                    // De-dupe only the same file; allow parallel across other files
                    if (this._activeSummaries.has(key)) {
                        Utils.log('APP', `Already summarizing ${key}`);
                        return;
                    }

                    // Mark this file as summarizing and update the button for the *current* selection
                    this._activeSummaries.add(key);
                    this._updateSummarizeButtonForCurrentSelection();

                    try {
                        // Show skeleton only if this file is still the one being viewed
                        const isStillSelected = this._key(this._currentParams?.alertId, this.getSelectedFileId()) === key;
                        if (summaryEl && isStillSelected) {
                            summaryEl.innerHTML =
                                '<div class="skel" aria-hidden="true">' +
                                '<div class="line" style="width:64%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:88%"></div>' +
                                '<div class="line" style="width:64%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:26%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:77%"></div>' +
                                '<div class="line" style="width:87%"></div>' +
                                '<div class="line" style="width:82%"></div>' +
                                '</div>';
                        }

                        const summary = await APIService.callOpenAI(
                            this._currentCleanedText,
                            this._currentParams.openaiKey,
                            CONFIG.OPENAI.MODEL,
                            (delta, full) => {
                                // Live-stream ONLY to the currently viewed file
                                const selectedKey = this._key(this._currentParams?.alertId, this.getSelectedFileId());
                                if (summaryEl && selectedKey === key) {
                                    summaryEl.innerHTML = SANITIZE(full);
                                }
                            }
                        );

                        // Final render (only if user is still on this file)
                        const stillSelected = this._key(this._currentParams?.alertId, this.getSelectedFileId()) === key;
                        if (summaryEl && stillSelected) {
                            const safeFinal = SANITIZE(summary);
                            summaryEl.innerHTML = safeFinal;
                            // Cache the sanitized version
                            this._summaryCache.set(summaryCacheKey, safeFinal);
                        }

                        if (this._summaryCache.size > 15) {
                            const firstKey = this._summaryCache.keys().next().value;
                            this._summaryCache.delete(firstKey);
                        }

                        Utils.log('APP', `Summary cached for file: ${fileId}`);
                    } catch (error) {
                        Utils.log('APP', 'Summarization failed', error);
                        const selectedKey = this._key(this._currentParams?.alertId, this.getSelectedFileId());
                        if (summaryEl && selectedKey === key) {
                            summaryEl.textContent = `Error generating summary: ${error.message}`;
                        }
                    } finally {
                        // Always clear the per-file busy flag, then refresh the button for what's currently shown
                        this._activeSummaries.delete(key);
                        this._updateSummarizeButtonForCurrentSelection();
                    }

                }
            };

            // =============================================================================
            // PUBLIC API
            // =============================================================================
            return {
                init: App.init.bind(App),
                getSelectedFileId: App.getSelectedFileId.bind(App),

                async getSASToken(username, password) {
                    return APIService.getSASToken(username, password);
                },
                clearToken() {
                    return APIService.clearToken();
                },
                async getFileContent(alertId, fileId, username, password) {
                    return APIService.getFileContent(alertId, fileId, username, password);
                },
                async extractTextFromFile(fileData) {
                    return APIService.extractTextFromFile(fileData);
                },
                async extractTextFromPDF(arrayBuffer, onProgress = null) {
                    return APIService.extractTextFromPDF(arrayBuffer, onProgress);
                },
                cleanTextForLLM(text, options = {}) {
                    return Utils.cleanTextForLLM(text, options);
                },
                _modules: {
                    Utils,
                    UIManager,
                    APIService,
                    VAIntegration,
                    CONFIG
                }
            };
        })();

        // =============================================================================
        // APPLICATION STARTUP
        // =============================================================================
        DocumentSummarizerApp.init();
    </script>
</body>

</html>

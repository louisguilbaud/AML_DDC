<!--
Written by Tsun Wai Wong, Anton Johansson & ChatGPT
Date: September 2025
tsunwai.wong@sas.com
anton.johansson@sas.com
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <!--
    Document Summarizer Application
    =============================
    A comprehensive document processing and AI-powered summarization tool that supports
    multiple file formats (PDF, DOCX, TXT) with both summary generation and interactive
    chat capabilities. Built for SAS environments with modern responsive design.

    Key Features:
    - Multi-format document parsing and text extraction
    - AI-powered summarization with configurable parameters
    - Interactive chat interface for document Q&A
    - Real-time file search and filtering
    - Modal document preview with full content display
    - Responsive design supporting desktop and mobile
    -->

    <!-- Standard HTML5 metadata for character encoding and responsive design -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Document Summarizer</title>

    <!--
    External Library Dependencies
    ============================
    These libraries provide core functionality for document processing and security.
    All CDN resources use integrity checking and CORS policies for security.
    -->

    <!-- SAS internal messaging utility for iframe communication and data exchange -->
    <script src="./javascripts/sas/util/messagingUtil.js"></script>

    <!--
    Mammoth.js v1.4.2 - Microsoft Word (.docx) document parser
    Converts .docx files to HTML while preserving formatting and structure.
    Used for extracting readable text content from Word documents.
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>

    <!--
    PDF.js v3.11.174 - Mozilla's PDF rendering and text extraction library
    Provides client-side PDF parsing without requiring server-side processing.
    Enables text extraction from PDF documents for summarization.
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!--
    DOMPurify v3.1.6 - XSS sanitization library with integrity verification
    Sanitizes HTML content from uploaded documents to prevent XSS attacks.
    Critical security component for handling user-uploaded content safely.
    -->
    <script src="https://unpkg.com/dompurify@3.1.6/dist/purify.min.js"
        integrity="sha384-+VfUPEb0PdtChMwmBcBmykRMDd+v6D/oFmB3rZM/puCMDYcIvF968OimRh4KQY9a" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <style>
        /*
        Application Stylesheet
        ======================
        Comprehensive styling for the Document Summarizer application using modern CSS
        with custom properties, responsive design, and accessibility considerations.

        Architecture:
        1. CSS Custom Properties (Theme System)
        2. Base Typography & Layout
        3. Component-Specific Styles
        4. Interactive States & Animations
        5. Responsive Breakpoints
        6. Accessibility Enhancements
        */

        /*
        CSS Custom Properties - Design System Foundation
        ===============================================
        Central theme configuration using CSS custom properties for consistent
        styling across all components. Enables easy theme switching and maintenance.
        */
        :root {
            /*
            Color Palette - Base Theme Colors
            ================================
            Semantic color tokens following design system conventions
            */
            --bg: #fff;                    /* Main background color */
            --fg: #1d1d1f;                 /* Primary text color (high contrast) */
            --muted: #6e6e73;              /* Secondary text color (reduced contrast) */
            --card: #fff;                  /* Card/surface background color */
            --border: rgba(0, 0, 0, .08);  /* Subtle border color with transparency */

            /*
            Brand Colors - Primary Action Colors
            ===================================
            SAS brand-compliant primary colors for interactive elements
            */
            --primary: #0478CE;            /* Primary brand color (SAS blue) */
            --primary-press: #0366AF;      /* Darker variant for pressed/active states */
            --grey-soft: #fafafa;          /* Light grey for surface backgrounds */
            --primary-soft: #E8F3FF;       /* Light blue for primary surface variants */

            /*
            Layout & Spacing Constants
            ==========================
            Consistent spacing values used throughout the application
            */
            --content-indent: 14px;        /* Standard content indentation */

            /*
            Animation Properties - File Loading Effects
            ==========================================
            Configuration for subtle loading animations on file items
            */
            --file-wave-min: .5;           /* Minimum opacity for wave animation (0-1) */
            --file-wave-width: 30%;        /* Width of the animated wave effect */
            --file-wave-speed: 2.8s;       /* Duration of wave animation cycle */

            /*
            Typography Scale - Font Size System
            ==================================
            Semantic font size tokens for consistent typography hierarchy
            Matches AML demo test final font size system exactly
            */
            --fs-1: 12px;                  /* Smallest text - model disclaimers */
            --fs-2: 13px;                  /* Small text - labels, captions, summary cutoff */
            --fs-3: 14px;                  /* Small+ text - general disclaimers */
            --fs-4: 15px;                  /* Medium-small - subtitles, secondary buttons, selects, tab labels */
            --fs-5: 16px;                  /* Base text - summary content, textareas, messages, inputs, comments */
            --fs-6: 17px;                  /* Base+ text - body text, primary buttons */
            --fs-7: 19px;                  /* Medium heading - summary h2 subheadings */
            --fs-8: 26px;                  /* Large heading - summary h1 headings */
            --fs-9: 30px;                  /* Largest heading - main page title */

            /*
            Component-Specific Dimensions
            ============================
            Standardized measurements for consistent component sizing
            */
            --toggle-height: 40px;         /* Height of the view toggle component */
            --chat-line: 1.45;             /* Line height for chat message text */
        }

        /*
        Global Reset & Base Styles
        ==========================
        Foundation styles for consistent cross-browser rendering
        */
        * {
            box-sizing: border-box        /* Consistent box model for all elements */
        }

        html,
        body {
            height: 100%                  /* Full viewport height for proper layout */
        }

        body {
            margin: 0;                    /* Remove default margins */
            background: var(--bg);        /* Apply theme background color */
            color: var(--fg);             /* Apply theme text color */
            /* System font stack for optimal performance and native appearance */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, system-ui;
            font-size: var(--fs-5);       /* Base font size from design system */
        }

        /*
        Main Layout Container
        ====================
        Responsive container that centers content and provides appropriate margins
        */
        .container {
            width: min(96vw, 1600px);     /* Responsive width with max constraint */
            margin: 2vh auto 8vh;         /* Vertical centering with breathing room */
            padding: 0 24px               /* Horizontal padding for mobile spacing */
        }

        /*
        Primary Card Component
        =====================
        Main application container with elevated appearance and rounded corners
        */
        .card {
            background: var(--card);      /* Theme-based background */
            border: 1px solid var(--border); /* Subtle border definition */
            border-radius: 24px;          /* Large radius for modern appearance */
            /* Layered shadow for depth: subtle close shadow + soft distant shadow */
            box-shadow: 0 1px 2px rgba(0, 0, 0, .04), 0 8px 30px rgba(0, 0, 0, .06);
            padding: 24px 24px 28px;      /* Balanced padding with extra bottom space */
            display: grid;                /* Grid layout for section management */
            gap: 18px;                    /* Consistent spacing between sections */
        }

        /*
        Application Header
        =================
        Top section containing title, subtitle, and primary action buttons
        */
        .header {
            display: flex;                /* Horizontal layout */
            justify-content: space-between; /* Title left, actions right */
            align-items: flex-start;      /* Top alignment for varied content heights */
            gap: 12px                     /* Spacing between title and action areas */
        }

        /*
        Typography Components
        ====================
        Styled text elements following the design system hierarchy
        */
        h1 {
            margin: 0 0 6px 0;            /* Minimal bottom margin for tight spacing */
            font-size: var(--fs-9);       /* Largest size from typography scale */
            font-weight: 650;             /* Semi-bold weight for prominence */
            letter-spacing: -.02em        /* Slight negative tracking for large text */
        }

        .subtitle {
            margin: 0;                    /* No margin for clean stacking */
            color: var(--muted);          /* Muted color for secondary importance */
            font-size: var(--fs-5);       /* Base font size */
        }

        .header>div:first-child {
            padding-left: var(--content-indent) /* Consistent indentation alignment */
        }

        /*
        Section Labels & Content Surfaces
        ================================
        Reusable components for section headers and content containers
        */
        .label {
            font-size: var(--fs-2);      /* Small size for section labels */
            text-transform: uppercase;     /* Uppercase for visual distinction */
            letter-spacing: .08em;        /* Wide tracking for uppercase readability */
            color: var(--muted);          /* Muted color for hierarchy */
            margin-bottom: 8px;           /* Space before associated content */
            padding-left: var(--content-indent) /* Alignment with other content */
        }

        .surface {
            border: 1px solid var(--border); /* Subtle border definition */
            border-radius: 14px;          /* Consistent border radius */
            background: var(--grey-soft);  /* Light background for content areas */
            padding: 14px;                /* Internal spacing for content */
            overflow: auto;               /* Handle content overflow with scrolling */
            font-size: var(--fs-5);       /* Standard text size */
        }

        /*
        Main Layout Grid
        ===============
        Two-column layout: fixed sidebar for file list, flexible main content area
        */
        .grid {
            display: grid;                /* CSS Grid for precise layout control */
            grid-template-columns: 320px 1fr; /* Fixed sidebar + flexible content */
            gap: 18px;                    /* Consistent gap between columns */
            min-height: 500px;            /* Minimum height for proper proportions */
        }

        /*
        Left Column - File List Sidebar
        ==============================
        Fixed-width sidebar containing document collection and search functionality
        */
        .left {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 80vh;             /* Limit height to prevent excessive scrolling */
            position: sticky;             /* Stick to viewport during scroll */
            top: 20px;                    /* Offset from top when sticky */
        }

        .left .surface {
            flex: 1;                      /* Expand to fill available space */
            min-height: 0;                /* Allow shrinking below content size */
        }

        /*
        Right Column - Main Content Area
        ===============================
        Flexible content area for document preview and AI-generated summaries
        */
        .right {
            display: flex;
            flex-direction: column;
            gap: 20px;                    /* Larger gap for content separation */
            align-items: stretch;         /* Full width for all children */
        }

        .right>section {
            display: flex;
            flex-direction: column;
        }

        .right>section:first-child {
            flex-shrink: 0;
            /* Keep file content at fixed height */
        }

        .right>section:last-child {
            flex: 1 0 auto;
            /* Allow summary to expand */
        }

        .right .surface {
            flex: 1;
            min-height: 0;
        }

        /* Force a taller summary pane before content renders */
        .right .summary-box {
            min-height: 320px;
        }

        /* File list */
        .search {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            position: relative;
        }

        .search-wrapper {
            position: relative;
            width: 100%;
        }

        .search input {
            width: 100%;
            padding: 10px 36px 10px 12px;
            border: 1px solid var(--border);
            border-radius: 14px;
            background: #fff;
            outline: none;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: var(--muted);
            transition: all 0.15s ease;
        }

        .search-clear:hover {
            background: rgba(0, 0, 0, 0.06);
            color: var(--fg);
        }

        .search-clear.visible {
            display: flex;
            /* Show when visible class is added */
        }

        /* The X icon using CSS */
        .search-clear::before,
        .search-clear::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 1.5px;
            background: currentColor;
            border-radius: 1px;
        }

        .search-clear::before {
            transform: rotate(45deg);
        }

        .search-clear::after {
            transform: rotate(-45deg);
        }


        .filelist {
            display: grid;
            gap: 8px
        }


        .file {
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 10px;
            background: #fff;
            cursor: pointer;
            display: grid;
            gap: 2px
        }

        .file:hover {
            background: var(--grey-soft);
            border-color: var(--border)
        }

        .file.is-active {
            background: var(--primary-soft);
            border-color: #CFE7FF
        }

        .file .name {
            font-weight: 600;
            font-size: var(--fs-3);
        }

        .file .meta {
            font-size: var(--fs-2);
            color: var(--muted);
        }

        /*  special "All Documents" row + separator */
        .filelist .divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        .file.all-docs .meta {
            font-style: italic
        }


        /* Button */
        .row {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .btn-primary {
            appearance: none;
            border: none;
            cursor: pointer;
            background: var(--primary);
            color: #fff;
            border-radius: 14px;
            padding: 12px 18px;
            font-size: var(--fs-5);
            font-weight: 600;
            box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
            font-size: var(--fs-7);
        }

        .btn-primary:hover {
            filter: brightness(1.02)
        }

        .btn-primary:active {
            transform: scale(.985)
        }

        .btn-primary:disabled {
            opacity: .65;
            cursor: not-allowed;
            box-shadow: none
        }

        .btn-primary:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(4, 120, 206, .12)
        }

        /* Make button host spinner + label inline */
        .btn-primary {
            display: inline-flex;
            /* ADD */
            align-items: center;
            /* ADD */
            gap: 8px;
            /* ADD */
            transition: transform .06s, box-shadow .2s, filter .2s;
            /* ADD */
        }

        /* Inline spinner exactly like other app */
        .spinner {
            /* ADD */
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, .6);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        /* Swap label <-> spinner while loading */
        .loading .spinner {
            display: inline-block;
        }

        .loading .labeltext {
            display: none;
        }

        /* Remove top margins from ALL first elements inside these containers */
        #summaryContent>*:first-child,
        #summaryContent article:first-child,
        #summaryContent h1:first-child,
        #summaryContent h2:first-child,
        #summaryContent h3:first-child,
        #summaryContent p:first-child {
            margin-top: 0 !important;
        }

        /* Also ensure article elements don't add spacing */
        #summaryContent article {
            margin: 0;
            padding: 0;
        }

        /* Ensure all heading elements inside summary don't add extra top margin when they're first */
        #summaryContent>article>*:first-child {
            margin-top: 0 !important;
        }

        /* Fix any potential spacing from the muted text spans */
        .muted {
            color: var(--muted);
            display: inline-block;
            margin: 0;
            padding: 0;
        }

        /* Ensure the processing-status doesn't add margin */
        .processing-status {
            color: var(--primary);
            font-style: italic;
            margin: 0;
            padding: 0;
        }


        #summaryContent {
            word-wrap: break-word;
            font-family: inherit;
            margin: 0;
            font-size: var(--fs-5);
            line-height: 1.6;
        }

        #summaryContent h2 {
            font-size: var(--fs-7);
            margin: 0 0 6px;
        }

        #summaryContent h3 {
            font-size: var(--fs-6);
            margin: 12px 0 6px;
        }

        /* Add these new rules */
        #summaryContent>*:first-child {
            margin-top: 0;
        }

        #summaryContent>*:last-child {
            margin-bottom: 0;
        }

        /* normal HTML flow */

        /* Status message */
        #out {
            display: none;
        }

        .processing-status {
            color: var(--primary);
            font-style: italic
        }

        .muted {
            color: var(--muted)
        }

        /* Loading state */
        .loading-message {
            color: var(--muted);
            font-style: italic;
            padding: 8px;
        }

        /*
        Responsive Design Breakpoints
        ============================
        Mobile-first responsive adjustments for optimal viewing on all devices
        */
        @media (max-width:1024px) {
            .grid {
                grid-template-columns: 1fr;  /* Single column layout on mobile */
            }

            .left {
                max-height: 300px;          /* Reduced height for mobile viewing */
                position: relative;         /* Remove sticky behavior on mobile */
                top: auto;                  /* Reset top positioning */
            }
        }


        .summary-box {
            min-height: 200px;
            /* Ensure minimum height */
            max-height: none;
            /* Allow unlimited expansion */
        }

        /*
        Skeleton Loading Animation
        =========================
        Provides visual feedback during content loading with animated placeholder lines
        */
        .skel {
            display: grid;                /* Grid layout for line organization */
            gap: 8px;                     /* Spacing between skeleton lines */
            margin: 0;                    /* No external margins */
        }

        .skel .line {
            height: 10px;                 /* Standard line height for text simulation */
            border-radius: 6px;           /* Rounded corners for softer appearance */
            /* Animated gradient that creates shimmer effect */
            background: linear-gradient(90deg, #ececec, #f7f7f7, #ececec);
            background-size: 200% 100%;   /* Double width for animation movement */
            animation: shimmer 2.5s linear infinite; /* Continuous shimmer animation */
        }

        /*
        Skeleton Accessibility
        =====================
        Prevent text selection on loading placeholders to avoid user confusion
        */
        .skel,
        .skel * {
            user-select: none;            /* Standard property */
            -webkit-user-select: none;    /* Webkit browsers */
            -webkit-touch-callout: none;  /* iOS Safari touch callouts */
        }

        /*
        Shimmer Animation Keyframes
        ==========================
        Creates a subtle flowing effect across skeleton loading elements
        */
        @keyframes shimmer {
            0% {
                background-position: 200% 0; /* Start with gradient off-screen right */
            }

            100% {
                background-position: -200% 0; /* End with gradient off-screen left */
            }
        }

        /*
        View Toggle Component (Summary ↔ Chat)
        =====================================
        Segmented control for switching between Summary and Chat modes
        Features animated pill indicator and accessibility support
        */
        .viewtoggle {
            position: relative;           /* Required for pill positioning */
            display: flex;                /* Horizontal layout for labels */
            align-items: center;          /* Vertical centering */
            gap: 0;                       /* No gap between segments */
            width: 200px;                 /* Fixed width for consistent sizing */
            height: var(--toggle-height); /* Consistent height from design system */
            padding: 4px;                 /* Internal padding for pill movement */
            border-radius: 999px;         /* Fully rounded pill shape */
            background: var(--grey-soft); /* Light background for inactive state */
            border: 1px solid var(--border); /* Subtle border definition */
            font-weight: 600;             /* Semi-bold text for prominence */
            user-select: none;            /* Prevent text selection */
            cursor: pointer               /* Indicate interactivity */
        }

        .viewtoggle .label {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--fs-2);
            margin: 0;
            padding: 0;
            text-transform: none;
            letter-spacing: 0;
            line-height: 1;
            color: var(--muted);
            position: relative;
            z-index: 1
        }

        .viewtoggle .pill {
            position: absolute;
            top: 4px;
            left: 4px;
            height: calc(var(--toggle-height) - 8px);
            width: calc(50% - 4px);
            border-radius: 999px;
            background: var(--primary);
            box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
            transition: transform .0s;
            z-index: 0;
            pointer-events: none
        }

        .card:not(.show-chat) .viewtoggle .label:first-child,
        .card.show-chat .viewtoggle .label:nth-child(2) {
            color: #fff !important
        }

        .card.show-chat .viewtoggle .pill {
            transform: translateX(100%)
        }

        /* Hide Summarize button in Chat mode (same behavior as Alert app) */
        .card.show-chat #summarizeBtn {
            display: none
        }

        /* Pane visibility control */
        #pane-chat {
            display: none
        }

        .card.show-chat #pane-chat {
            display: block
        }

        .card.show-chat #pane-summary {
            display: none
        }

        /* Inline disclaimer in Chat mode */
        .card.show-chat::after {
            content: "Generative AI can make mistakes. Check important info.";
            display: block;
            margin-top: 7px;
            font-size: var(--fs-1);
            color: var(--muted);
            text-align: center
        }

        /*
        Chat Interface Components
        ========================
        Interactive chat UI for document Q&A functionality
        Reused and adapted from Alert Summarizer application
        */
        .chat {
            border: 1px solid var(--border); /* Consistent border styling */
            border-radius: 14px;          /* Matching application border radius */
            background: var(--grey-soft);  /* Light background for content area */
            padding: 14px;                /* Internal spacing */
            display: flex;                /* Vertical stacking layout */
            flex-direction: column;
            gap: 10px                     /* Spacing between chat elements */
        }

        .chat-messages {
            min-height: 273px;
            max-height: clamp(360px, 55vh, 720px);
            overflow: auto;
            display: grid;
            gap: 10px;
            padding-right: 4px;
            align-content: start;
            align-items: start;
            grid-auto-rows: max-content
        }

        .msg {
            display: flex
        }

        .msg .bubble {
            border: 1px solid var(--border);
            background: #f7f7f7;
            color: var(--fg);
            padding: 10px 12px;
            border-radius: 14px 14px 4px 14px;
            font-size: var(--fs-5);
            line-height: var(--chat-line);
            line-height: var(--chat-line);
            max-width: 72%;
            box-shadow: 0 1px 2px rgba(0, 0, 0, .04)
        }

        .msg.bot .bubble {
            background: #fff;
            color: var(--fg);
            border-color: var(--border)
        }

        .msg.user {
            justify-content: flex-end
        }

        .msg.user .bubble {
            background: var(--primary-soft);
            color: var(--fg);
            border-color: var(--border);
            border-radius: 14px 14px 14px 4px
        }

        .chat-input {
            display: flex;
            gap: 8px
        }

        #chatText {
            flex: 1;
            border: 1px solid rgba(0, 0, 0, .12);
            border-radius: 14px;
            font: inherit;
            outline: none;
            font-size: var(--fs-5);
            padding: 14px 16px;
            /* a little extra padding for bigger text */
        }

        #chatText:focus {
            border-color: var(--primary-press);
            box-shadow: 0 0 0 4px rgba(10, 132, 255, .12)
        }

        .typing {
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        .typing .dots {
            display: inline-flex;
            gap: 4px
        }

        .typing .dots i {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--muted);
            opacity: .35;
            animation: dotpulse 1s ease-in-out infinite;
            transform: translateY(0);
        }

        .typing .dots i:nth-child(2) {
            animation-delay: .2s
        }

        .typing .dots i:nth-child(3) {
            animation-delay: .4s
        }

        /*
        Typing Indicator Animation
        =========================
        Subtle pulsing animation for chat typing indicators
        Creates engaging visual feedback during AI response generation
        */
        @keyframes dotpulse {

            0%,
            100% {
                transform: translateY(0);   /* Neutral position */
                opacity: .25                /* Low opacity for subtle effect */
            }

            50% {
                transform: translateY(-3px); /* Slight upward movement */
                opacity: 1                  /* Full opacity at peak */
            }
        }

        /* === Small icon button on file rows === */
        .icon-btn {
            appearance: none;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            line-height: 0;
        }

        .icon-btn:hover {
            background: rgba(0, 0, 0, .05);
        }

        .icon-btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(4, 120, 206, .15);
        }

        /* If using an <img> inside the icon button */
        .icon-btn img {
            display: block;
            width: 16px;
            height: 16px;
        }

        /* File row layout now has an actions area on the right */
        .file {
            display: flex;
            /* <-- was grid */
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .file .main {
            display: grid;
            gap: 2px;
        }

        .file .actions {
            flex: 0 0 auto;
        }

        /* === Fullscreen-ish modal === */
        .content-modal[hidden] {
            display: none;
        }

        .content-modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .content-modal__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, .4);
        }

        .content-modal__panel {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: min(1400px, 94vw);
            height: min(80vh, 900px);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 18px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-modal__header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
        }

        .content-modal__title {
            margin: 0;
            font-size: var(--fs-5);
            font-weight: 650;
        }

        .content-modal__body {
            padding: 12px 16px;
            overflow: auto;
            background: var(--grey-soft);
            height: 100%;
        }

        #modalFileContent {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, system-ui;
            font-size: var(--fs-5);
            line-height: 1.5;
        }

        /* Close button inherits .icon-btn; make it a bit larger */
        .close-btn {
            font-size: var(--fs-8);
            padding: 2px 8px;
            line-height: 1;
        }

        /* Optional: when modal is open, prevent page scroll */
        body.modal-open {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- Main application container: provides consistent layout and responsive behavior -->
    <div class="container">
        <!-- Primary card interface: ARIA region for screen readers, labeled by main title -->
        <div class="card" role="region" aria-labelledby="title">
            <!--
                APPLICATION HEADER SECTION
                Contains: Main title, subtitle, primary action button, and view toggle
                Layout: Flexbox row with space-between alignment for responsive design
                State: Button disabled until document selected, toggle controls view switching
            -->
            <div class="header">
                <!-- Title section: Main app branding and descriptive subtitle -->
                <div>
                    <h1 id="title">Document Summarizer</h1>
                    <p class="subtitle">Generate a concise summary with one click.</p>
                </div>
                <!-- Action controls: Primary button and view toggle in horizontal layout -->
                <div class="row">
                    <!--
                        PRIMARY ACTION BUTTON: Summarize
                        - Disabled state until document is selected
                        - Contains loading spinner for async operations
                        - Auto-hidden via CSS when in Chat mode (.chat-mode class)
                        - aria-busy attribute updated during processing for screen readers
                    -->
                    <button id="summarizeBtn" class="btn-primary" type="button" disabled aria-busy="false">
                        <span class="spinner" aria-hidden="true"></span>
                        <span class="labeltext">Summarize</span>
                    </button>
                    <!--
                        VIEW MODE TOGGLE: Summary ↔ Chat
                        - ARIA switch role for accessibility
                        - aria-checked reflects current state (false=Summary, true=Chat)
                        - Visual pill indicator slides between positions
                        - Controls visibility of #pane-summary vs #pane-chat
                    -->
                    <div id="viewToggle" class="viewtoggle" role="switch" aria-checked="false"
                        aria-label="Toggle summary or chat">
                        <span class="label">Summary</span>
                        <span class="label">Chat</span>
                        <span class="pill" aria-hidden="true"></span>
                    </div>
                </div>
            </div>

            <!--
                DOCUMENT CONTENT MODAL
                Purpose: Full-screen overlay displaying raw document content
                Accessibility: WAI-ARIA dialog pattern with focus trap and ESC key handling
                Interaction: Click backdrop or close button to dismiss
                State: Hidden by default, shown when user clicks document title
            -->
            <div id="contentModal" class="content-modal" hidden>
                <!-- Modal backdrop: Semi-transparent overlay, clickable to close modal -->
                <div class="content-modal__backdrop" data-close="true" aria-hidden="true"></div>

                <!--
                    Modal panel: Main content container
                    - role="dialog" + aria-modal="true" for screen reader focus management
                    - aria-labelledby points to modal title for context
                    - Focus trapped within this element when open
                -->
                <div class="content-modal__panel" role="dialog" aria-modal="true" aria-labelledby="contentModalTitle">
                    <!-- Modal header: Title and close button -->
                    <div class="content-modal__header">
                        <h2 id="contentModalTitle" class="content-modal__title">Document content</h2>
                        <!-- Close button: Accessible with keyboard and screen readers -->
                        <button id="contentModalClose" class="icon-btn close-btn" type="button"
                            aria-label="Close">&times;</button>
                    </div>

                    <!--
                        Modal body: Document content display
                        - <pre> preserves formatting for text files
                        - Content loaded dynamically via JavaScript
                        - Supports various file types (text, PDF, etc.)
                    -->
                    <div class="content-modal__body">
                        <pre id="modalFileContent">Loading…</pre>
                    </div>
                </div>
            </div>

            <!--
                MAIN APPLICATION LAYOUT
                Grid system: Two-column responsive layout (documents sidebar + main content)
                Breakpoints: Stacks vertically on mobile, side-by-side on desktop
                Grid areas: 'left' (documents) and 'right' (summary/chat panes)
            -->
            <div class="grid">
                <!--
                    DOCUMENTS SIDEBAR (Left Column)
                    Purpose: Document selection and search interface
                    Accessibility: ARIA landmark with descriptive label
                    Features: Real-time search filtering, document list, loading states
                -->
                <aside class="left" aria-label="Documents">
                    <!-- Sidebar header: Label and search controls -->
                    <div>
                        <div class="label">Documents</div>
                        <!--
                            SEARCH INTERFACE
                            Features: Live filtering, clear button, keyboard navigation
                            Behavior: Filters document list in real-time as user types
                        -->
                        <div class="search">
                            <div class="search-wrapper">
                                <!-- Search input: Filters document list dynamically -->
                                <input id="searchInput" placeholder="Search documents…" />
                                <!-- Clear button: Resets search and shows all documents -->
                                <button id="searchClear" class="search-clear" type="button"
                                    aria-label="Clear search"></button>
                            </div>
                        </div>
                    </div>
                    <!--
                        DOCUMENT LIST CONTAINER
                        States: Loading, empty, populated with documents
                        Content: Dynamically populated via VA parameters and SAS API
                        Interaction: Click documents to select and load content
                    -->
                    <div class="surface">
                        <div id="filelist" class="filelist">
                            <!-- Initial loading state: Shown until VA parameters are available -->
                            <div class="loading-message">Waiting for VA parameters...</div>
                        </div>
                    </div>
                </aside>

                <!--
                    MAIN CONTENT AREA (Right Column)
                    Purpose: Display summary or chat interface based on view toggle
                    Layout: Contains two mutually exclusive panes controlled by CSS classes
                    Responsive: Full width on mobile, right column on desktop
                -->
                <main class="right">
                    <!--
                        SUMMARY PANE
                        Visibility: Shown by default, hidden when .chat-mode class applied to body
                        Purpose: Display AI-generated document summaries
                        State: Loading, empty, or populated with summary content
                    -->
                    <div id="pane-summary">
                        <section>
                            <div class="label">Summary</div>
                            <!--
                                SUMMARY DISPLAY CONTAINER
                                Accessibility: ARIA label for screen readers, live region for updates
                                Content: Dynamically populated via OpenAI API responses
                                Styling: Card-like surface with appropriate spacing
                            -->
                            <div class="surface summary-box" aria-label="AI Summary">
                                <!--
                                    Summary content area with live updates
                                    - aria-live="polite" announces changes to screen readers
                                    - Content sanitized to prevent XSS attacks
                                    - Shows placeholder text when empty
                                -->
                                <div id="summaryContent" aria-live="polite">
                                    <span class="muted">AI summary will appear here...</span>
                                </div>
                            </div>
                        </section>
                    </div>

                    <!--
                        CHAT PANE
                        Visibility: Hidden by default, shown when .chat-mode class applied to body
                        Purpose: Interactive Q&A interface for document-based conversations
                        Features: Message history, input field, send button with validation
                    -->
                    <div id="pane-chat">
                        <section>
                            <div class="label">Chat</div>
                            <!--
                                CHAT INTERFACE CONTAINER
                                Layout: Message area above input field (typical chat pattern)
                                Behavior: Auto-scroll to latest messages, keyboard submit support
                            -->
                            <div class="chat" id="chat">
                                <!--
                                    CHAT MESSAGE HISTORY
                                    - ARIA region for message context
                                    - Live region announces new messages to screen readers
                                    - Auto-scrolls to bottom on new messages
                                    - Contains user and AI message bubbles
                                -->
                                <div id="chatMessages" class="chat-messages" role="region" aria-live="polite"></div>
                                <!--
                                    CHAT INPUT CONTROLS
                                    Layout: Input field with adjacent send button
                                    Behavior: Enter key submits, button disabled when empty/processing
                                    Validation: Requires non-empty input and selected document
                                -->
                                <div class="chat-input">
                                    <!-- Text input: Supports Enter key submission -->
                                    <input id="chatText" type="text" placeholder="Ask about this document…" />
                                    <!-- Send button: Disabled until valid input and document selected -->
                                    <button id="chatSendBtn" class="btn-primary" type="button" disabled>Send</button>
                                </div>
                            </div>
                        </section>
                    </div>
                </main>
            </div>

            <!--
                LEGACY COMPATIBILITY ELEMENTS
                Purpose: Support for older VA integration patterns and debugging
                Visibility: Hidden from UI but accessible to JavaScript for backwards compatibility
                Usage: VA report integration may expect these elements to exist
            -->
            <!-- Legacy output container: May be used by VA for communication -->
            <div id="out" style="display:none"></div>
            <!-- Legacy file selector: Backup interface for file selection -->
            <select id="fileSelect" style="display:none">
                <option value="">— select a file —</option>
            </select>
            <!-- Legacy file counter: May display document count in some contexts -->
            <small id="fileCount" style="display:none"></small>
        </div>
    </div>

    <script>
        /**
         * VA Document Summarizer Application
         *
         * Enterprise-grade document processing application that integrates SAS Visual Analytics
         * with OpenAI services for AI-powered document summarization and interactive chat.
         *
         * Architecture follows modular design principles with:
         * - Centralized configuration management
         * - Security-first approach with content sanitization
         * - Performance optimization through preloading and caching
         * - Robust error handling and retry mechanisms
         * - Clean separation of concerns between modules
         */
        const DocumentSummarizerApp = (() => {
            // =============================================================================
            // CONFIGURATION - Centralized settings for maintainability and deployment
            // =============================================================================

            /**
             * Master configuration object containing all application settings.
             * Organized by functional domain for clarity and maintainability.
             *
             * Design principles:
             * - Single source of truth for all configuration
             * - Environment-agnostic structure for easy deployment
             * - Performance tuning through configurable intervals and limits
             * - Security through explicit allow-listing and sanitization
             */
            const CONFIG = {
                // SAS Server Integration - Production SAS Viya environment
                // Used for document retrieval, authentication, and VA parameter passing
                SAS_SERVER: 'https://sasserver.demo.sas.com',

                /**
                 * SAS Authentication Configuration
                 * Implements OAuth 2.0 client credentials flow for secure API access
                 *
                 * Security considerations:
                 * - Uses SAS CLI client for reduced attack surface
                 * - Empty client secret follows SAS public client pattern
                 * - Token endpoint provides centralized authentication
                 */
                SAS_AUTH: {
                    CLIENT_ID: 'sas.cli', // Default SAS CLI client ID - pre-configured in SAS environment
                    CLIENT_SECRET: '', // Usually empty for CLI client - follows OAuth public client pattern
                    TOKEN_ENDPOINT: '/SASLogon/oauth/token' // Standard SAS OAuth endpoint
                },

                /**
                 * VA Parameter Mapping
                 * Maps Visual Analytics report parameters to array indices for reliable data extraction.
                 *
                 * Parameter flow: VA Report -> URL Parameters -> Array indices -> Application state
                 * Critical for secure credential passing from VA environment to application
                 */
                PARAMETER_INDEXES: {
                    alertId: 0,    // Document/alert identifier for context
                    openaiKey: 1,  // OpenAI API key - passed securely from VA environment
                    sasUser: 2,    // SAS username for authenticated requests
                    sasPass: 3     // SAS password - handled securely, never logged
                },

                // Network resilience - Interval for retrying failed VA operations (milliseconds)
                // Balances responsiveness with server load during network issues
                VA_RETRY_INTERVAL: 1000,

                /**
                 * DOM Element ID Registry
                 * Centralized mapping of HTML element IDs for consistent DOM manipulation.
                 *
                 * Benefits:
                 * - Single point of change for UI refactoring
                 * - Prevents typos in element selection
                 * - Clear documentation of UI component relationships
                 */
                ELEMENTS: {
                    output: 'out',                    // Main output container
                    fileSelect: 'fileSelect',         // File selection dropdown
                    fileCount: 'fileCount',           // Document count display
                    summarizeBtn: 'summarizeBtn',     // Primary action button
                    summaryContent: 'summaryContent', // Summary display area
                    filelist: 'filelist',             // Document list container
                    searchInput: 'searchInput',       // Search functionality
                    viewToggle: 'viewToggle',         // View mode switcher
                    chatText: 'chatText',             // Chat input field
                    chatSendBtn: 'chatSendBtn',       // Chat send button
                    chatMessages: 'chatMessages'      // Chat conversation display
                },

                /**
                 * OpenAI API Integration Settings
                 * Configuration for external AI service integration
                 *
                 * Security note: API key is passed from secure VA environment,
                 * never hardcoded in client-side code
                 */
                OPENAI: {
                    URL: 'https://api.openai.com/v1/responses', // OpenAI API endpoint
                    MODEL: 'gpt-5-nano' // Model selection - optimized for document processing tasks
                },

                /**
                 * PDF Processing Configuration
                 * PDF.js library settings for client-side document processing
                 *
                 * Uses CDN for reliability and performance, specific version pinned
                 * for consistency across deployments
                 */
                PDF: {
                    WORKER_SRC: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
                },

                /**
                 * Auto-refresh Mechanism
                 * Keeps document list current without manual user intervention
                 *
                 * Performance consideration: 4-second interval balances freshness
                 * with server load and user experience
                 */
                AUTO_REFRESH: {
                    ENABLED: true,
                    INTERVAL: 4000 // milliseconds - tuned for optimal user experience
                },

                /**
                 * Intelligent Preloading Strategy
                 * Performance optimization through predictive document loading
                 *
                 * Benefits:
                 * - Reduces perceived latency for document access
                 * - Implements throttling to prevent server overload
                 * - Configurable limits for different deployment scenarios
                 */
                PRELOAD: {
                    ENABLED: true,
                    COUNT: 10,     // Number of documents to preload - balances performance vs memory
                    DELAY: 200     // Milliseconds between requests - server-friendly throttling
                },

                /**
                 * User Interface Text Configuration
                 * Centralized UI text management for internationalization readiness
                 * and consistent user experience across different application modes
                 */
                HEADINGS: {
                    summary: {
                        title: 'Document Summarizer',
                        subtitle: 'Generate a concise summary with one click.'
                    },
                    chat: {
                        title: 'Document Chat',
                        subtitle: 'Ask questions about this document.'
                    }
                },

                /**
                 * Special Value Constants
                 * Application-wide constants for special states and operations
                 *
                 * Using distinctive prefixes (__) to avoid collisions with real data
                 */
                SPECIAL: {
                    ALL_ID: '__ALL__',        // Identifier for "all documents" operations
                    ALL_NAME: 'All Documents' // Display name for bulk operations
                }
            };

            /**
             * HTML Content Sanitization Function
             *
             * Critical security measure that prevents XSS attacks from LLM-generated content.
             * Uses DOMPurify with strict allow-list approach - only explicitly permitted
             * HTML elements are allowed, all others are stripped.
             *
             * Security architecture:
             * - Default-deny policy: blocks all HTML by default
             * - Explicit allow-list: only safe formatting tags permitted
             * - No attributes allowed: prevents event handlers and style injection
             * - Designed for LLM output: handles AI-generated content safely
             *
             * Threat model: Protects against malicious content in AI responses
             * that could execute scripts or steal user data
             */
            const SANITIZE = (html) => DOMPurify.sanitize(html, {
                ALLOWED_TAGS: ['article', 'h2', 'h3', 'p', 'ul', 'ol', 'li', 'strong', 'em', 'blockquote'],
                ALLOWED_ATTR: [] // Zero attributes policy - maximum security
            });

            /**
             * PDF.js Worker Initialization
             *
             * Configures PDF processing worker for optimal performance and security.
             * Worker runs in separate thread to prevent UI blocking during PDF parsing.
             *
             * Implementation notes:
             * - Conditional initialization prevents errors when PDF.js not available
             * - Uses versioned CDN URL for consistent behavior across deployments
             * - Worker approach ensures main thread remains responsive during processing
             */
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.PDF.WORKER_SRC;
            }

            // =============================================================================
            // UTILITIES
            // =============================================================================
            /**
             * Utility functions for text processing, security, and data formatting.
             * These utilities provide foundational operations used throughout the application
             * with emphasis on security, performance, and reliability.
             */
            const Utils = {
                /**
                 * Escapes HTML special characters to prevent XSS attacks.
                 *
                 * Security Implementation:
                 * - Converts all HTML-sensitive characters to their entity equivalents
                 * - Uses object literal lookup for O(1) character replacement performance
                 * - Handles null/undefined inputs safely by converting to string
                 * - Protects against injection attacks when displaying user content
                 *
                 * Performance Notes:
                 * - Single regex pass with callback function for efficient processing
                 * - Object literal lookup avoids multiple conditional checks
                 * - String() conversion ensures type safety without throwing errors
                 *
                 * @param {any} s - Input value to escape (automatically converted to string)
                 * @returns {string} HTML-safe string with escaped special characters
                 */
                escapeHtml(s = '') { return String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])) },

                /**
                 * Strips HTML tags and extracts plain text content.
                 *
                 * Security Considerations:
                 * - Uses DOM-based parsing to handle complex HTML structures safely
                 * - Relies on browser's built-in HTML parser to avoid custom parsing vulnerabilities
                 * - Prevents script execution by using innerHTML without appending to live DOM
                 * - Falls back to innerText for IE compatibility
                 *
                 * Performance Notes:
                 * - Creates temporary DOM element for parsing (lightweight operation)
                 * - Leverages browser's optimized text extraction methods
                 * - Automatic memory cleanup when element goes out of scope
                 *
                 * @param {any} s - HTML string to strip (automatically converted to string)
                 * @returns {string} Plain text content with HTML tags removed and whitespace trimmed
                 */
                stripHtml(s = '') {
                    const div = document.createElement('div');
                    div.innerHTML = String(s);
                    return (div.textContent || div.innerText || '').trim();
                },

                /**
                 * Safely extracts parameter values from VA (Visual Analytics) parameter arrays.
                 *
                 * Integration Pattern:
                 * - Designed for SAS Visual Analytics parameter passing convention
                 * - Handles the VA parameter structure: [{value: 'data', label: 'display'}]
                 * - Provides safe access to avoid runtime errors with malformed parameters
                 *
                 * Error Handling:
                 * - Returns undefined for invalid inputs rather than throwing exceptions
                 * - Guards against non-array parameters and out-of-bounds access
                 * - Null-safe parameter object property access
                 *
                 * @param {Array} params - VA parameters array with {value, label} objects
                 * @param {number} index - Zero-based index of parameter to retrieve
                 * @returns {any|undefined} Parameter value or undefined if not found/invalid
                 */
                getParamByIndex(params, index) {
                    return (Array.isArray(params) && params[index]) ? params[index].value : undefined;
                },

                /**
                 * Converts an object to a URL-encoded query string.
                 *
                 * Standards Compliance:
                 * - Uses URLSearchParams for proper RFC 3986 URL encoding
                 * - Handles special characters, spaces, and unicode correctly
                 * - Automatically encodes array values and null/undefined properties
                 *
                 * Performance:
                 * - Leverages native browser API for optimal encoding performance
                 * - More efficient than manual string concatenation approaches
                 * - Built-in handling of edge cases and encoding rules
                 *
                 * @param {Object} obj - Plain object with key-value pairs to encode
                 * @returns {string} URL-encoded query string (without leading '?')
                 */
                createQueryString(obj) {
                    return new URLSearchParams(obj).toString();
                },

                /**
                 * Provides structured logging with consistent formatting across the application.
                 *
                 * Logging Strategy:
                 * - Categorized logging for easier filtering and debugging
                 * - Conditional data logging to avoid JSON serialization overhead
                 * - Standardized format: [CATEGORY] message
                 *
                 * Performance Considerations:
                 * - Avoids unnecessary object serialization when no data provided
                 * - Template literal formatting for efficient string construction
                 * - Leverages console.log's built-in object formatting for complex data
                 *
                 * Development Benefits:
                 * - Easy filtering by category in browser dev tools
                 * - Consistent format across all application components
                 * - Optional structured data logging for debugging complex objects
                 *
                 * @param {string} category - Log category for filtering (e.g., 'API', 'UI', 'AUTH')
                 * @param {string} message - Descriptive log message
                 * @param {any} [data=null] - Optional data object to log alongside message
                 */
                log(category, message, data = null) {
                    const logMessage = `[${category}] ${message}`;
                    if (data) {
                        console.log(logMessage, data);
                    } else {
                        console.log(logMessage);
                    }
                },

                /**
                 * Optimizes text content for Large Language Model (LLM) processing.
                 *
                 * Text Processing Algorithm:
                 * - Multi-stage cleaning pipeline for optimal LLM input quality
                 * - Configurable processing steps for different content types
                 * - Sequential processing order optimizes for performance and accuracy
                 *
                 * Unicode Handling:
                 * - Removes control characters (\u0000-\u001F, \u007F-\u009F) that can disrupt parsing
                 * - Eliminates zero-width and formatting characters (\u200B-\u200D, \uFEFF)
                 * - Normalizes various unicode whitespace types to standard spaces
                 *
                 * Performance Optimizations:
                 * - Conditional processing based on options to avoid unnecessary operations
                 * - Single-pass regex operations where possible
                 * - Efficient string operations using native methods
                 *
                 * LLM Benefits:
                 * - Reduces token count by eliminating redundant whitespace
                 * - Improves parsing accuracy by normalizing text structure
                 * - Prevents encoding issues in API requests
                 *
                 * @param {string} text - Raw text content to clean
                 * @param {Object} [options={}] - Cleaning configuration options
                 * @param {boolean} [options.removeExtraSpaces=true] - Collapse multiple spaces to single space
                 * @param {boolean} [options.removeSpecialChars=true] - Remove control and formatting characters
                 * @param {boolean} [options.normalizeWhitespace=true] - Convert unicode whitespace to standard spaces
                 * @param {boolean} [options.removeEmptyLines=true] - Remove lines containing only whitespace
                 * @param {boolean} [options.trimLines=true] - Trim whitespace from start/end of each line
                 * @param {number} [options.maxConsecutiveNewlines=2] - Limit consecutive newlines
                 * @returns {string} Cleaned and optimized text for LLM processing
                 */
                cleanTextForLLM(text, options = {}) {
                    const defaults = {
                        removeExtraSpaces: true,
                        removeSpecialChars: true,
                        normalizeWhitespace: true,
                        removeEmptyLines: true,
                        trimLines: true,
                        maxConsecutiveNewlines: 2
                    };

                    const settings = { ...defaults, ...options };

                    let cleaned = text || '';

                    // Remove control characters and zero-width characters that can interfere with LLM parsing
                    if (settings.removeSpecialChars) {
                        // Remove C0 and C1 control characters (excluding tab \u0009, LF \u000A, CR \u000D)
                        cleaned = cleaned.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '');
                        // Remove zero-width spaces, joiners, and byte order marks
                        cleaned = cleaned.replace(/[\u200B-\u200D\uFEFF]/g, '');
                    }

                    // Normalize various unicode whitespace characters to standard space for consistency
                    if (settings.normalizeWhitespace) {
                        // Convert non-breaking spaces, em spaces, en spaces, etc. to regular space
                        cleaned = cleaned.replace(/[\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]/g, ' ');
                        // Convert tabs to spaces for uniform formatting
                        cleaned = cleaned.replace(/\t/g, ' ');
                    }

                    // Collapse multiple consecutive spaces while preserving line breaks
                    if (settings.removeExtraSpaces) {
                        // Match any whitespace except \r and \n (preserves line structure)
                        cleaned = cleaned.replace(/[^\S\r\n]+/g, ' ');
                    }

                    // Remove leading and trailing whitespace from each line
                    if (settings.trimLines) {
                        cleaned = cleaned.split('\n').map(line => line.trim()).join('\n');
                    }

                    // Remove completely empty lines to reduce token count
                    if (settings.removeEmptyLines) {
                        cleaned = cleaned.split('\n').filter(line => line.length > 0).join('\n');
                    }

                    // Limit consecutive newlines to prevent excessive whitespace
                    if (settings.maxConsecutiveNewlines > 0) {
                        // Dynamic regex construction to match (maxConsecutiveNewlines + 1) or more newlines
                        const regex = new RegExp(`\\n{${settings.maxConsecutiveNewlines + 1},}`, 'g');
                        const replacement = '\n'.repeat(settings.maxConsecutiveNewlines);
                        cleaned = cleaned.replace(regex, replacement);
                    }

                    return cleaned.trim();
                },

                /**
                 * Converts byte values to human-readable file size representations.
                 *
                 * Algorithm:
                 * - Uses binary (1024-based) calculation for accurate file system representation
                 * - Logarithmic calculation determines appropriate unit scale efficiently
                 * - Single decimal precision balances readability with accuracy
                 *
                 * Performance:
                 * - O(1) calculation using mathematical operations
                 * - Avoids iterative loops for scale determination
                 * - Minimal string formatting overhead
                 *
                 * Edge Cases:
                 * - Handles zero, null, and undefined inputs gracefully
                 * - Supports up to GB scale (sufficient for typical document files)
                 * - Returns descriptive fallback for invalid inputs
                 *
                 * @param {number} bytes - File size in bytes
                 * @returns {string} Formatted size string (e.g., "1.5 MB", "512 KB")
                 */
                formatFileSize(bytes) {
                    if (!bytes) return 'Unknown size';
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${sizes[i]}`;
                },

                /**
                 * Determines user-friendly file type display names from filenames.
                 *
                 * File Type Detection:
                 * - Extracts extension from filename using last dot as delimiter
                 * - Case-insensitive matching for robust extension recognition
                 * - Supports common document formats used in business environments
                 *
                 * Extension Mapping Strategy:
                 * - Predefined lookup table for known document types
                 * - Fallback to uppercase extension for unknown types
                 * - Consistent naming convention for user display
                 *
                 * Performance:
                 * - O(1) lookup using object property access
                 * - Single string operation for extension extraction
                 * - Minimal processing overhead for UI display
                 *
                 * @param {string} filename - Full filename with extension
                 * @returns {string} User-friendly file type (e.g., "PDF", "DOCX", "TXT")
                 */
                getFileTypeDisplay(filename) {
                    if (!filename) return 'File';
                    const ext = filename.split('.').pop().toLowerCase();
                    const types = {
                        'pdf': 'PDF',
                        'docx': 'DOCX',
                        'doc': 'DOC',
                        'txt': 'TXT',
                        'text': 'TXT',
                        'csv': 'CSV',
                        'xlsx': 'XLSX',
                        'xls': 'XLS'
                    };
                    return types[ext] || ext.toUpperCase();
                }
            };

            // =============================================================================
            // UI MANAGER
            // =============================================================================
            /**
             * Manages user interface interactions, state synchronization, and DOM manipulation
             * for the document summarizer application. Implements reactive UI patterns with
             * centralized state management and event-driven updates.
             *
             * Architecture Patterns:
             * - Observer pattern for UI state synchronization
             * - Command pattern for user action handling
             * - State management with immutable updates
             * - Event delegation for efficient DOM event handling
             *
             * Performance Optimizations:
             * - Batch DOM updates to minimize reflows
             * - Event delegation to reduce memory usage
             * - Selective rendering based on state changes
             * - Efficient search filtering with real-time updates
             */
            const UIManager = {
                /**
                 * Internal state: Complete file collection for filtering and display.
                 * Cached to avoid repeated API calls and enable client-side filtering.
                 * @private
                 */
                _allFiles: [],

                /**
                 * Internal state: Currently selected file identifier.
                 * Used for maintaining selection state across UI updates and page refreshes.
                 * @private
                 */
                _selectedFileId: null,

                /**
                 * Updates the main output display with status messages and results.
                 *
                 * UI Update Strategy:
                 * - Uses textContent for XSS prevention (no HTML injection possible)
                 * - Conditional append mode for progressive message display
                 * - Graceful degradation if output element not found
                 *
                 * Performance:
                 * - Single DOM query and update per call
                 * - textContent is faster than innerHTML for plain text
                 * - No DOM node creation overhead
                 *
                 * @param {string} message - Text message to display
                 * @param {boolean} [append=false] - Whether to append to existing content
                 */
                updateOutput(message, append = false) {
                    const element = document.getElementById(CONFIG.ELEMENTS.output);
                    if (element) {
                        element.textContent = append ? element.textContent + message : message;
                    }
                },

                /**
                 * Convenience method to append messages with automatic line break formatting.
                 *
                 * User Experience:
                 * - Automatic newline prepending for readable message separation
                 * - Consistent formatting across all append operations
                 * - Simplifies caller code by handling formatting internally
                 *
                 * @param {string} message - Message to append to output
                 */
                appendOutput(message) {
                    this.updateOutput(`\n${message}`, true);
                },

                /**
                 * Renders the interactive file list with selection capabilities and metadata display.
                 *
                 * UI Architecture:
                 * - Virtual "All Documents" option for batch operations
                 * - Individual file items with click handlers and action buttons
                 * - Event delegation pattern for efficient memory usage
                 * - Visual separator between special and regular items
                 *
                 * State Management:
                 * - Preserves current selection across re-renders
                 * - Caches file data for filtering operations
                 * - Synchronizes with hidden select element for compatibility
                 *
                 * Performance Optimizations:
                 * - Single innerHTML clear followed by batch DOM insertion
                 * - Event listeners attached after DOM creation
                 * - Selective re-filtering only when search term exists
                 *
                 * Accessibility Features:
                 * - Proper ARIA labels for icon buttons
                 * - Keyboard navigation support via click event handling
                 * - Screen reader friendly file metadata display
                 *
                 * @param {Array} files - Array of file objects with id, name, size properties
                 */
                populateFileList(files) {
                    this._allFiles = files;
                    const listEl = document.getElementById(CONFIG.ELEMENTS.filelist);
                    if (!listEl) return;

                    const currentSelection = this._selectedFileId;

                    if (!files || files.length === 0) {
                        listEl.innerHTML = '<div class="loading-message">No files available</div>';
                        return;
                    }

                    listEl.innerHTML = '';

                    // Create virtual "All Documents" option for batch operations
                    // This provides users with a way to process multiple files simultaneously
                    const allEl = document.createElement('div');
                    allEl.className = 'file all-docs';
                    allEl.dataset.fileId = CONFIG.SPECIAL.ALL_ID;
                    allEl.dataset.fileName = CONFIG.SPECIAL.ALL_NAME.toLowerCase();
                    if (String(currentSelection) === CONFIG.SPECIAL.ALL_ID) allEl.classList.add('is-active');
                    allEl.innerHTML = `
    <div class="name">${CONFIG.SPECIAL.ALL_NAME}</div>
    <div class="meta">${files.length} documents</div>
  `;
                    allEl.addEventListener('click', () => { this.selectFile(CONFIG.SPECIAL.ALL_ID); });
                    listEl.appendChild(allEl);

                    // Visual separator improves UI hierarchy and user comprehension
                    // Distinguishes special "All Documents" option from individual files
                    const sep = document.createElement('div');
                    sep.className = 'divider';
                    listEl.appendChild(sep);

                    // Render individual file entries with interactive elements
                    files.forEach(file => {
                        // Defensive property access to handle different API response formats
                        const id = file.id || file.fileId;
                        const name = file.name || file.fileName || id;
                        const size = file.size || file.fileSize || 0;

                        const fileEl = document.createElement('div');
                        fileEl.className = 'file';
                        fileEl.dataset.fileId = String(id);
                        // Lowercase filename for case-insensitive search filtering
                        fileEl.dataset.fileName = name.toLowerCase();

                        // Restore selection state across UI updates
                        if (String(id) === String(currentSelection)) fileEl.classList.add('is-active');

                        // Structured HTML with semantic organization for accessibility
                        fileEl.innerHTML = `
  <div class="main">
    <div class="name">${name}</div>
    <div class="meta">${Utils.getFileTypeDisplay(name)} · ${Utils.formatFileSize(size)}</div>
  </div>
  <div class="actions">
    <button class="icon-btn open-btn" type="button" aria-label="Open content" title="Open content">
      <svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true">
        <path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3zM5 5h6v2H7v10h10v-4h2v6H5V5z"></path>
      </svg>
    </button>
  </div>
`;

                        // Main click handler for file selection
                        fileEl.addEventListener('click', () => { this.selectFile(id); });
                        listEl.appendChild(fileEl);

                        // Secondary action: content preview modal (independent of selection)
                        // Event propagation stopped to prevent triggering parent click handler
                        const openBtn = fileEl.querySelector('.open-btn');
                        openBtn.addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            App.openContentModal(String(id), String(name));
                        });
                    });

                    // Maintain compatibility with legacy select-based interface
                    // Ensures consistent state between new list UI and hidden select element
                    this.populateFileDropdown(files);

                    // Preserve user's search state across file list updates
                    // Prevents search term loss during dynamic content refreshes
                    const searchInput = document.getElementById(CONFIG.ELEMENTS.searchInput);
                    if (searchInput && searchInput.value) this.filterFiles(searchInput.value);

                    // Trigger UI state validation to update dependent components
                    // Uses optional chaining to avoid errors if app not fully initialized
                    window.DocumentSummarizerApp?._updateBtn?.();
                },

                /**
                 * Updates application state and UI to reflect file selection.
                 *
                 * State Management:
                 * - Centralizes selection state in this._selectedFileId
                 * - Synchronizes UI visual indicators across all interface elements
                 * - Maintains consistency between modern list UI and legacy select element
                 *
                 * UI Update Strategy:
                 * - Batch DOM class updates for smooth visual transitions
                 * - Uses dataset attributes for efficient element identification
                 * - Updates all relevant UI components in single operation
                 *
                 * Event Handling:
                 * - Triggers downstream selection handlers via global app instance
                 * - Uses optional chaining for safe method invocation
                 * - Ensures selection changes propagate to all dependent components
                 *
                 * @param {string|number} fileId - Unique identifier for selected file
                 */
                selectFile(fileId) {
                    this._selectedFileId = String(fileId);

                    // Update visual selection indicators across all file items
                    // Single querySelectorAll for efficient DOM traversal
                    document.querySelectorAll('.file').forEach(el => {
                        if (el.dataset.fileId === String(fileId)) {
                            el.classList.add('is-active');
                        } else {
                            el.classList.remove('is-active');
                        }
                    });

                    // Maintain synchronization with legacy select element interface
                    // Ensures compatibility with existing event handlers and form processing
                    const selectEl = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    if (selectEl) {
                        selectEl.value = String(fileId);
                    }

                    // Notify application layer of selection change for data loading
                    // Decoupled architecture allows flexible handler registration
                    if (window.DocumentSummarizerApp?._onFileSelected) {
                        window.DocumentSummarizerApp._onFileSelected(String(fileId));
                    }
                },
                /**
                 * Implements real-time client-side file filtering based on filename matching.
                 *
                 * Search Algorithm:
                 * - Case-insensitive substring matching for user-friendly search
                 * - Instant visual feedback without server round-trips
                 * - Preserves special "All Documents" option in all search states
                 *
                 * Performance:
                 * - O(n) complexity for filtering operation
                 * - Direct DOM manipulation for immediate visual response
                 * - No debouncing needed due to lightweight operation
                 *
                 * User Experience:
                 * - Progressive disclosure: shows matching items as user types
                 * - No pagination disruption during search
                 * - Clear visual feedback for empty search results
                 *
                 * @param {string} searchTerm - User input search string
                 */
                filterFiles(searchTerm) {
                    const term = searchTerm.toLowerCase();
                    document.querySelectorAll('.file').forEach(el => {
                        const isAll = el.classList.contains('all-docs');
                        // Always show "All Documents" option regardless of search term
                        if (isAll) { el.style.display = ''; return; }

                        // Use pre-computed lowercase filename for efficient matching
                        const fileName = el.dataset.fileName || '';
                        if (fileName.includes(term)) {
                            el.style.display = '';
                        } else {
                            el.style.display = 'none';
                        }
                    });
                },

                /**
                 * Maintains legacy select element interface for backward compatibility.
                 *
                 * Compatibility Strategy:
                 * - Preserves existing form-based workflows and event handlers
                 * - Enables graceful degradation when JavaScript enhanced UI unavailable
                 * - Supports automated testing frameworks expecting select elements
                 *
                 * DOM Management:
                 * - Efficient innerHTML replacement for bulk option updates
                 * - createElement approach for individual options ensures proper encoding
                 * - Defensive programming with element existence checks
                 *
                 * User Feedback:
                 * - Descriptive placeholder option for clear user guidance
                 * - File count display for collection size awareness
                 * - Consistent empty state messaging
                 *
                 * @param {Array} files - File collection for select option generation
                 * @returns {string} Count text for testing/validation purposes
                 */
                populateFileDropdown(files) {
                    const selectEl = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    const countEl = document.getElementById(CONFIG.ELEMENTS.fileCount);

                    if (!selectEl || !countEl) return;

                    // Clear existing options and add default placeholder
                    selectEl.innerHTML = '<option value="">— select a file —</option>';

                    // Generate option elements with proper value/text encoding
                    files.forEach(file => {
                        const id = file.id || file.fileId;
                        const name = file.name || file.fileName || id;
                        const option = document.createElement('option');
                        option.value = String(id);
                        option.textContent = name; // textContent prevents XSS
                        selectEl.appendChild(option);
                    });

                    // Update file count indicator for user awareness
                    const countText = files.length ? `(${files.length} files)` : '(no files)';
                    countEl.textContent = countText;
                    return countText;
                },

                /**
                 * Displays error states with consistent messaging across UI components.
                 *
                 * Error Handling Strategy:
                 * - Dual-location error display for comprehensive user notification
                 * - Output area for detailed/persistent error information
                 * - File list area for contextual error state indication
                 *
                 * User Experience:
                 * - Clear error prefixing for easy identification
                 * - Consistent styling via loading-message class
                 * - Non-blocking error display (doesn't prevent other interactions)
                 *
                 * Security:
                 * - Uses template literal and innerHTML with controlled content
                 * - Error message should be sanitized by caller if user-generated
                 *
                 * @param {string} message - Error description to display to user
                 */
                showError(message) {
                    // Add error to main output for detailed logging
                    this.appendOutput(`\nError: ${message}`);

                    // Update file list area with contextual error state
                    const listEl = document.getElementById(CONFIG.ELEMENTS.filelist);
                    if (listEl) {
                        listEl.innerHTML = `<div class="loading-message">Error: ${message}</div>`;
                    }
                },


                /**
                 * Initializes event handlers for all interactive UI components.
                 *
                 * Event Handling Architecture:
                 * - Centralized event listener registration for maintainable code
                 * - Event delegation where appropriate to minimize memory usage
                 * - Progressive enhancement with graceful degradation
                 *
                 * User Interaction Patterns:
                 * - Real-time search with visual feedback
                 * - Keyboard accessibility for power users
                 * - Multiple interaction methods (click, keyboard, etc.)
                 *
                 * Performance Considerations:
                 * - Event listener registration during initialization (not per-element)
                 * - Efficient event handling without unnecessary DOM queries
                 * - Debouncing not needed for lightweight operations
                 */
                setupEventListeners() {
                    // Search interface with real-time filtering and accessibility features
                    const searchInput = document.getElementById(CONFIG.ELEMENTS.searchInput);
                    const searchClear = document.getElementById('searchClear');
                    if (searchInput && searchClear) {
                        // Real-time search with immediate visual feedback
                        searchInput.addEventListener('input', (e) => {
                            const hasValue = e.target.value.length > 0;

                            // Dynamic clear button visibility for intuitive UX
                            if (hasValue) {
                                searchClear.classList.add('visible');
                            } else {
                                searchClear.classList.remove('visible');
                            }

                            // Apply filter immediately for responsive user experience
                            this.filterFiles(e.target.value);
                        });

                        // Clear button provides quick reset functionality
                        searchClear.addEventListener('click', () => {
                            searchInput.value = '';
                            searchClear.classList.remove('visible');
                            this.filterFiles(''); // Reset filter to show all files
                            searchInput.focus(); // Maintain keyboard accessibility
                        });

                        // Keyboard accessibility: ESC key for quick clearing
                        // Enhances power user experience and accessibility compliance
                        searchInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape' && e.target.value) {
                                searchInput.value = '';
                                searchClear.classList.remove('visible');
                                this.filterFiles('');
                            }
                        });

                    }

                    // Legacy select element interface for backward compatibility
                    // Maintains support for form-based interactions and automated testing
                    const fileSelect = document.getElementById(CONFIG.ELEMENTS.fileSelect);
                    if (fileSelect) {
                        fileSelect.addEventListener('change', (event) => {
                            const fileId = event.target.value;
                            if (fileId) {
                                // Log selection for debugging and analytics
                                Utils.log('UI', `File selected: ${fileId}`);

                                // Trigger application-level selection handler
                                if (window.DocumentSummarizerApp && window.DocumentSummarizerApp._onFileSelected) {
                                    window.DocumentSummarizerApp._onFileSelected(fileId);
                                }
                            } else {
                                // Handle deselection: clear internal state and update dependent UI
                                this._selectedFileId = null;
                                window.DocumentSummarizerApp?._updateBtn?.();
                            }
                        });
                    }

                    // Main action button for document summarization workflow
                    // Delegates to application layer for business logic processing
                    const summarizeBtn = document.getElementById(CONFIG.ELEMENTS.summarizeBtn);
                    if (summarizeBtn) {
                        summarizeBtn.addEventListener('click', () => {
                            // Invoke application-level summarization handler
                            // Uses optional chaining for safe method invocation during initialization
                            if (window.DocumentSummarizerApp && window.DocumentSummarizerApp._onSummarizeClick) {
                                window.DocumentSummarizerApp._onSummarizeClick();
                            }
                        });
                    }
                }
            };

            // =============================================================================
            // API SERVICE
            // =============================================================================
            /**
             * Handles all external network requests, including SAS authentication,
             * data fetching from SAS servers, and communication with the OpenAI API.
             * It encapsulates authentication, data parsing, and text extraction logic.
             */
            const APIService = {
                // In-memory cache for the SAS OAuth2 access token to avoid re-authentication.
                _accessToken: null,

                /**
                 * Acquires a SAS access token using the OAuth2 password grant type.
                 * This is the primary authentication mechanism against the SAS server.
                 * @param {string} username - The user's SAS username.
                 * @param {string} password - The user's SAS password.
                 * @returns {Promise<string>} A promise that resolves with the access token.
                 * @throws {Error} If authentication fails due to network issues or invalid credentials.
                 */
                async getSASToken(username, password) {
                    const url = `${CONFIG.SAS_SERVER}${CONFIG.SAS_AUTH.TOKEN_ENDPOINT}`;
                    Utils.log('AUTH', `Getting SAS token from: ${url}`);

                    try {
                        // Credentials for the client application itself, base64 encoded.
                        const credentials = btoa(`${CONFIG.SAS_AUTH.CLIENT_ID}:${CONFIG.SAS_AUTH.CLIENT_SECRET}`);

                        const formData = new URLSearchParams({
                            'grant_type': 'password',
                            'username': username,
                            'password': password
                        });

                        const response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Basic ${credentials}`,
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'Accept': 'application/json'
                            },
                            body: formData
                        });

                        if (!response.ok) {
                            throw new Error(`Authentication failed: HTTP ${response.status} ${response.statusText}`);
                        }

                        const data = await response.json();
                        Utils.log('AUTH', 'Token received successfully');

                        this._accessToken = data.access_token;
                        return data.access_token;
                    } catch (error) {
                        Utils.log('AUTH', 'Token request failed', error);
                        throw new Error(`Failed to get SAS token: ${error.message}`);
                    }
                },

                /**
                 * Retrieves the current access token, using the cached token if available
                 * or fetching a new one if not.
                 * @param {string} username - SAS username, required if a new token is needed.
                 * @param {string} password - SAS password, required if a new token is needed.
                 * @returns {Promise<string>} A promise that resolves with the access token.
                 */
                async getAccessToken(username, password) {
                    if (!this._accessToken) {
                        this._accessToken = await this.getSASToken(username, password);
                    }
                    return this._accessToken;
                },

                /**
                 * Clears the cached access token, forcing re-authentication on the next API call.
                 * Useful for handling authentication errors or user logouts.
                 */
                clearToken() {
                    this._accessToken = null;
                    Utils.log('AUTH', 'Token cache cleared');
                },

                /**
                 * Fetches the list of files associated with a specific alert ID from the SAS server.
                 * It attempts an authenticated request first and falls back to an unauthenticated
                 * request if authentication fails.
                 * @param {string} alertId - The unique identifier for the alert.
                 * @param {string|null} [username=null] - Optional SAS username for authentication.
                 * @param {string|null} [password=null] - Optional SAS password for authentication.
                 * @returns {Promise<Array<Object>>} A promise that resolves to an array of file objects.
                 *   Each object typically contains `id`, `name`, and `size`.
                 * @throws {Error} If the network request fails and does not return a 2xx status.
                 */
                async fetchAlertFiles(alertId, username = null, password = null) {
                    const url = `${CONFIG.SAS_SERVER}/svi-datahub/documents/alerts/${encodeURIComponent(alertId)}/files`;
                    Utils.log('API', `Fetching files from: ${url}`);
                    UIManager.appendOutput('Fetching files from SAS API...');

                    try {
                        let headers = {
                            'Accept': 'application/json'
                        };

                        // If credentials are provided, attempt to get a token and use it.
                        if (username && password) {
                            try {
                                const token = await this.getAccessToken(username, password);
                                headers['Authorization'] = `Bearer ${token}`;
                                Utils.log('API', 'Using authenticated request');
                            } catch (authError) {
                                // Fallback: If auth fails, proceed with an unauthenticated request.
                                // This might be useful for public-facing data hubs.
                                Utils.log('API', 'Authentication failed, trying unauthenticated request', authError);
                                UIManager.appendOutput('\nAuthentication failed, trying without auth...');
                            }
                        }

                        const response = await fetch(url, {
                            method: 'GET',
                            headers: headers
                        });

                        Utils.log('API', `Response status: ${response.status}`);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        Utils.log('API', 'Full response received', data);

                        // Normalize the response structure to get the array of files.
                        const files = Array.isArray(data) ? data : (data.items || data.files || []);

                        Utils.log('FILES', `Parsed ${files.length} files`, files[0]);
                        return files;
                    } catch (error) {
                        Utils.log('API', 'Fetch failed', error);
                        throw error;
                    }
                },

                /**
                 * Retrieves the raw binary content of a specific file from the SAS server.
                 * @param {string} alertId - The identifier for the parent alert.
                 * @param {string} fileId - The identifier for the file.
                 * @param {string} username - SAS username for authentication.
                 * @param {string} password - SAS password for authentication.
                 * @returns {Promise<{contentType: string, arrayBuffer: ArrayBuffer}>} A promise resolving
                 *   to an object containing the file's MIME type and its content as an ArrayBuffer.
                 * @throws {Error} If the authenticated request fails.
                 */
                async getFileContent(alertId, fileId, username, password) {
                    const url = `${CONFIG.SAS_SERVER}/svi-datahub/documents/alerts/${encodeURIComponent(alertId)}/files/${encodeURIComponent(fileId)}/content`;
                    Utils.log('API', `Fetching file content: ${url}`);

                    try {
                        const token = await this.getAccessToken(username, password);

                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const contentType = response.headers.get('Content-Type') || '';
                        Utils.log('API', `File content type: ${contentType}`);

                        const arrayBuffer = await response.arrayBuffer();

                        return {
                            contentType: contentType,
                            arrayBuffer: arrayBuffer
                        };
                    } catch (error) {
                        Utils.log('API', 'File content fetch failed', error);
                        throw error;
                    }
                },

                /**
                 * Extracts text from a PDF file's binary content using the PDF.js library.
                 * Processes the PDF page by page to build a complete text representation.
                 * @param {ArrayBuffer} arrayBuffer - The binary content of the PDF file.
                 * @param {function(string):void|null} [onProgress=null] - An optional callback to report
                 *   progress (e.g., "Processing page 1 of 5").
                 * @returns {Promise<string>} A promise that resolves with the extracted plain text.
                 * @throws {Error} If PDF.js is not loaded or if parsing fails.
                 */
                async extractTextFromPDF(arrayBuffer, onProgress = null) {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.js library not loaded');
                    }

                    try {
                        Utils.log('PDF', 'Loading PDF document');
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        const numPages = pdf.numPages;
                        Utils.log('PDF', `PDF has ${numPages} pages`);

                        const textBuilder = [];

                        // Iterate through each page to extract text content.
                        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                            if (onProgress) {
                                onProgress(`Processing page ${pageNum} of ${numPages}`);
                            }

                            Utils.log('PDF', `Processing page ${pageNum}`);
                            try {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items
                                    .map(item => item.str)
                                    .join(' ')
                                    .trim();

                                if (pageText) {
                                    textBuilder.push(pageText);
                                }

                                // Clean up page resources to free memory.
                                page.cleanup();
                            } catch (pageError) {
                                Utils.log('PDF', `Error processing page ${pageNum}`, pageError);
                            }
                        }

                        // Clean up document resources.
                        pdf.destroy();

                        const fullText = textBuilder.join(' ').trim();
                        return fullText || '[No text content could be extracted from this PDF]';
                    } catch (error) {
                        Utils.log('PDF', 'PDF processing failed', error);
                        throw new Error(`PDF text extraction failed: ${error.message}`);
                    }
                },

                /**
                 * Extracts text from a file's binary data based on its MIME type.
                 * This acts as a factory, dispatching to the correct parsing library (PDF.js, Mammoth.js)
                 * or using a simple text decoder.
                 * @param {{contentType: string, arrayBuffer: ArrayBuffer}} fileData - The file's data.
                 * @param {function(string):void|null} [onProgress=null] - Optional progress callback.
                 * @returns {Promise<string>} A promise resolving with the extracted plain text.
                 */
                async extractTextFromFile(fileData, onProgress = null) {
                    const { contentType, arrayBuffer } = fileData;

                    try {
                        // Route to the correct parser based on the Content-Type header.
                        if (contentType.includes('pdf')) {
                            Utils.log('EXTRACT', 'Processing PDF document');
                            return await this.extractTextFromPDF(arrayBuffer, onProgress);
                        }
                        // Handles .docx (and older .doc) formats.
                        else if (contentType.includes('wordprocessingml.document') ||
                            contentType.includes('msword') ||
                            contentType.includes('word')) {
                            Utils.log('EXTRACT', 'Processing Word document');
                            if (typeof mammoth !== 'undefined') {
                                if (onProgress) {
                                    onProgress('Extracting text from Word document');
                                }
                                const result = await mammoth.extractRawText({ arrayBuffer });
                                return result.value;
                            } else {
                                // Fallback if the required library isn't loaded.
                                return `[WORD DOCUMENT DETECTED]\nContent type: ${contentType}\nFile size: ${arrayBuffer.byteLength} bytes\nMammoth.js not loaded - cannot extract text`;
                            }
                        }
                        // Handles all 'text/*' subtypes like 'text/plain', 'text/csv', etc.
                        else if (contentType.includes('text/plain') || contentType.includes('text/')) {
                            Utils.log('EXTRACT', 'Processing text file');
                            if (onProgress) {
                                onProgress('Reading text file');
                            }
                            const decoder = new TextDecoder('utf-8');
                            return decoder.decode(arrayBuffer);
                        }
                        // Fallback for unknown binary types: attempt to decode as UTF-8 text.
                        else {
                            Utils.log('EXTRACT', `Unknown content type: ${contentType}, trying text decode`);
                            if (onProgress) {
                                onProgress('Attempting to read as text file');
                            }
                            const decoder = new TextDecoder('utf-8');
                            return decoder.decode(arrayBuffer);
                        }
                    } catch (error) {
                        Utils.log('EXTRACT', 'Text extraction failed', error);
                        return `[ERROR EXTRACTING TEXT]\nContent type: ${contentType}\nError: ${error.message}\nFile size: ${arrayBuffer.byteLength} bytes`;
                    }
                },

                /**
                 * Calls the OpenAI API to generate a summary for one or more documents.
                 * It dynamically constructs the system prompt based on whether single or multiple
                 * documents are provided. It also handles token limits and streaming responses.
                 * @param {string} text - The document text. For multiple documents, a special
                 *   format with "==== [DOC n] ..." separators is expected.
                 * @param {string} apiKey - The OpenAI API key.
                 * @param {string} [model=CONFIG.OPENAI.MODEL] - The AI model to use.
                 * @param {function(string, string, Object):void|null} [onDelta=null] - If provided, enables
                 *   streaming. This callback receives `(delta, fullText, event)`.
                 * @returns {Promise<string>} A promise that resolves to the full summary text.
                 * @throws {Error} If the API call fails.
                 */
                async callOpenAI(text, apiKey, model = CONFIG.OPENAI.MODEL, onDelta) {
                    const isMulti = text.startsWith('[[MULTI_DOC]]') || text.includes('==== [DOC ');

                    // Define character limits to prevent excessive token usage and cost.
                    // These are heuristics based on average characters per page.
                    const CHARS_PER_PAGE = 2000;
                    const MAX_CHARS_PER_DOC = 20 * CHARS_PER_PAGE;  // ~20 pages
                    const MAX_CHARS_TOTAL = 120 * CHARS_PER_PAGE;   // ~120 pages

                    // Pre-process and clip text to fit within model context window constraints.
                    if (isMulti) {
                        text = this.clipMultiDocuments(text, MAX_CHARS_PER_DOC, MAX_CHARS_TOTAL);
                    } else {
                        // Simple clipping for a single large document.
                        if (text.length > MAX_CHARS_TOTAL) {
                            text = text.slice(0, MAX_CHARS_TOTAL) + '\n[...document trimmed]';
                        }
                    }

                    // Rationale: Use a specific, structured prompt for single documents to ensure
                    // consistent HTML output and summary format.
                    const singlePrompt = `You are a helpful assistant that creates concise, clear summaries in English.
Rules:
- Length: ≤ 1/4 of the input, and never more than 500 words.
- Output: strict, self-contained HTML5 (no Markdown).
- Use only: <article>, <h2>, <h3>, <p>, <ul>, <ol>, <li>, <strong>, <em>, <blockquote>.
- No <script>, <style>, images, iframes, links or inline events.
Structure:
<article>
  <h2>Title</h2>
  <p>One-sentence gist.</p>
  <h3>Key points</h3>
  <ul><li>…</li></ul>
  <h3>Details</h3>
  <p>…</p>
</article>

Summarize this document:\n\n${text}`;

                    // Rationale: Use a different prompt for multiple documents to instruct the model
                    // to synthesize information, deduplicate, and highlight unique points from each.
                    const multiPrompt = `You are a helpful assistant that summarizes a set of documents (marked by "==== [DOC n] <name> ====").
Rules:
- One cohesive HTML5 summary for ALL documents, ≤ 800 words total.
- Output: strict HTML5; allowed: <article>, <h2>, <h3>, <p>, <ul>, <ol>, <li>, <strong>, <em>, <blockquote>.
- Deduplicate, merge overlaps, note contradictions. No quotes/links.

Structure:
<article>
  <h2>Overall summary</h2>
  <p>1–2 sentence gist across all docs.</p>
  <h3>Key themes</h3>
  <ul><li>Theme — short rationale</li></ul>
  <h3>Per-document highlights</h3>
  <ul>
    <li><strong>DOC 1 — <em>name</em>:</strong> Most unique point from this document</li>
    <li><strong>DOC 2 — <em>name</em>:</strong> Most unique point from this document</li>
    <!-- one <li> per document -->
  </ul>
  <h3>Risks / disagreements</h3>
  <ul><li>…if any…</li></ul>
</article>

Summarize the set:\n\n${text}`;

                    const systemPrompt = isMulti ? multiPrompt : singlePrompt;

                    const body = {
                        model,
                        input: systemPrompt,
                        reasoning: { effort: "low" },
                        text: { verbosity: "low" },
                        stream: !!onDelta // Enable streaming if a callback is provided.
                    };
                    const res = await fetch(CONFIG.OPENAI.URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'Accept': onDelta ? 'text/event-stream' : 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    // Standard non-streaming response handling.
                    if (!onDelta) {
                        const json = await res.json().catch(() => ({}));
                        if (!res.ok) throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                        const txt = (json.output_text ?? json.choices?.[0]?.message?.content ?? '');
                        if (!txt) throw new Error('LLM returned no text payload');
                        return txt;
                    }

                    // Streaming response handling using Server-Sent Events (SSE).
                    if (!res.ok || !res.body) {
                        const text = await res.text().catch(() => '');
                        throw new Error(`${res.status} ${res.statusText}\n${text.slice(0, 500)}`);
                    }

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let carry = ''; // Buffer for incomplete event frames.
                    let full = '';  // The complete response text.

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        carry += decoder.decode(value, { stream: true });

                        // SSE frames are separated by double newlines.
                        const frames = carry.split('\n\n');
                        carry = frames.pop() || ''; // The last part might be an incomplete frame.

                        for (const frame of frames) {
                            const dataLines = frame
                                .split('\n')
                                .filter(l => l.startsWith('data:'))
                                .map(l => l.slice(5).trim())
                                .join('\n');

                            if (!dataLines || dataLines === '[DONE]') continue;

                            let evt;
                            try {
                                evt = JSON.parse(dataLines);
                            } catch {
                                continue; // Ignore malformed JSON frames.
                            }

                            // Process the text delta from the event.
                            if (evt.type === 'response.output_text.delta') {
                                const delta = evt.delta || '';
                                if (delta) {
                                    full += delta;
                                    try {
                                        // Call the user-provided callback with the new chunk.
                                        onDelta(delta, full, evt);
                                    } catch {
                                        /* ignore handler errors to not break the stream */
                                    }
                                }
                            } else if (evt.type === 'error') {
                                throw new Error(evt.error?.message || 'Streaming error');
                            }
                        }
                    }

                    return full.trim();
                },
                /**
                 * Calls the OpenAI API for document-grounded Q&A.
                 * This is a lightweight wrapper that passes a pre-constructed prompt directly
                 * to the API, supporting both streaming and non-streaming modes.
                 * @param {string} prompt - The complete, pre-formatted system prompt including
                 *   instructions, document context, and the user's question.
                 * @param {string} apiKey - The OpenAI API key.
                 * @param {string} [model=CONFIG.OPENAI.MODEL] - The AI model to use.
                 * @param {function(string, string, Object):void|null} [onDelta=null] - If provided, enables
                 *   streaming. This callback receives `(delta, fullText, event)`.
                 * @returns {Promise<string>} A promise that resolves to the full chat reply.
                 */
                async callOpenAIChat(prompt, apiKey, model = CONFIG.OPENAI.MODEL, onDelta) {
                    const body = {
                        model,
                        input: prompt, // Use the prompt exactly as built by the caller (e.g., Chat.buildPrompt).
                        reasoning: { effort: "low" },
                        text: { verbosity: "low" },
                        stream: !!onDelta
                    };

                    const res = await fetch(CONFIG.OPENAI.URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'Accept': onDelta ? 'text/event-stream' : 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    // Non-streaming path
                    if (!onDelta) {
                        const json = await res.json().catch(() => ({}));
                        if (!res.ok) throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                        const txt = (json.output_text ?? json.choices?.[0]?.message?.content ?? '');
                        if (!txt) throw new Error('LLM returned no text payload');
                        return txt;
                    }

                    // Streaming path (SSE) - logic is identical to callOpenAI.
                    if (!res.ok || !res.body) {
                        const text = await res.text().catch(() => '');
                        throw new Error(`${res.status} ${res.statusText}\n${text.slice(0, 500)}`);
                    }

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let carry = '';
                    let full = '';

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        carry += decoder.decode(value, { stream: true });

                        const frames = carry.split('\n\n');
                        carry = frames.pop() || '';

                        for (const frame of frames) {
                            const dataLines = frame
                                .split('\n')
                                .filter(l => l.startsWith('data:'))
                                .map(l => l.slice(5).trim())
                                .join('\n');

                            if (!dataLines || dataLines === '[DONE]') continue;

                            let evt;
                            try {
                                evt = JSON.parse(dataLines);
                            } catch {
                                continue;
                            }

                            if (evt.type === 'response.output_text.delta') {
                                const delta = evt.delta || '';
                                if (delta) {
                                    full += delta;
                                    try { onDelta(delta, full, evt); } catch { /* ignore handler errors */ }
                                }
                            } else if (evt.type === 'error') {
                                throw new Error(evt.error?.message || 'Streaming error');
                            }
                        }
                    }

                    return full.trim();
                },

                /**
                 * Pre-processes and clips text from multiple documents to fit within a total
                 * character limit, applying a per-document cap first, then proportionally
                 * reducing all documents if the total is still exceeded.
                 * @param {string} text - The combined text of all documents, with separators.
                 * @param {number} maxPerDoc - The maximum number of characters for any single document.
                 * @param {number} maxTotal - The maximum total characters for the entire payload.
                 * @returns {string} The processed and clipped text.
                 */
                clipMultiDocuments(text, maxPerDoc, maxTotal) {
                    // This function parses a string containing multiple documents, identified by
                    // "==== [DOC n] <name> ====" headers, and intelligently truncates them.

                    const docPattern = /==== \[DOC (\d+)\] (.*?) ====/g;
                    const matches = [];
                    let match;

                    // 1. Collect all document headers to understand the structure.
                    while ((match = docPattern.exec(text)) !== null) {
                        matches.push({
                            index: match.index,
                            num: match[1],
                            name: match[2],
                            header: match[0]
                        });
                    }

                    const preamble = matches.length > 0 ? text.slice(0, matches[0].index) : '';

                    // 2. Extract the content of each document.
                    const documents = matches.map((match, i) => {
                        const docStart = match.index + match.header.length;
                        const docEnd = i < matches.length - 1 ? matches[i + 1].index : text.length;
                        const content = text.slice(docStart, docEnd).trim();

                        return {
                            num: match.num,
                            name: match.name,
                            header: match.header,
                            content: content,
                            originalLength: content.length
                        };
                    });

                    // 3. First pass: clip individual documents that exceed the per-document limit.
                    let totalChars = preamble.length;
                    const clippedDocs = documents.map(doc => {
                        let content = doc.content;
                        if (content.length > maxPerDoc) {
                            const clipPoint = this.findSentenceBoundary(content, maxPerDoc);
                            content = content.slice(0, clipPoint) + '\n[...document trimmed from ' +
                                Math.round(doc.originalLength / 1000) + 'k to ' +
                                Math.round(clipPoint / 1000) + 'k chars]';
                        }

                        totalChars += doc.header.length + content.length + 2; // +2 for newlines

                        return {
                            ...doc,
                            content: content,
                            clipped: content.length < doc.originalLength
                        };
                    });

                    // 4. Second pass: if total is still too long, reduce all docs proportionally.
                    if (totalChars > maxTotal) {
                        const reductionRatio = (maxTotal - preamble.length) / (totalChars - preamble.length);

                        return preamble + clippedDocs.map(doc => {
                            const targetLength = Math.floor(doc.content.length * reductionRatio * 0.9); // 0.9 for safety margin
                            const clipPoint = this.findSentenceBoundary(doc.content, targetLength);
                            const clippedContent = doc.content.slice(0, clipPoint);

                            return doc.header + '\n' + clippedContent +
                                '\n[...trimmed to fit total limit]';
                        }).join('\n\n');
                    }

                    // 5. Reconstruct the final text if no proportional reduction was needed.
                    return preamble + clippedDocs.map(doc =>
                        doc.header + '\n' + doc.content
                    ).join('\n\n');
                },
                /**
                 * Finds a "natural" boundary (sentence, paragraph, or word) to trim text,
                 * avoiding mid-word or mid-sentence cuts for better LLM comprehension.
                 * @param {string} text - The text to search within.
                 * @param {number} targetLength - The desired maximum length.
                 * @returns {number} The index at which to clip the text.
                 */
                findSentenceBoundary(text, targetLength) {
                    if (text.length <= targetLength) return text.length;

                    // Search for a sentence end near the target length to make the cut less abrupt.
                    const searchStart = Math.max(0, targetLength - 200);
                    const searchText = text.slice(searchStart, targetLength);

                    const sentenceEnds = ['. ', '.\n', '! ', '!\n', '? ', '?\n'];
                    let lastEnd = -1;
                    let endChar = '';

                    for (const end of sentenceEnds) {
                        const pos = searchText.lastIndexOf(end);
                        if (pos > lastEnd) {
                            lastEnd = pos;
                            endChar = end;
                        }
                    }

                    if (lastEnd > -1) {
                        return searchStart + lastEnd + endChar.length;
                    }

                    // Fallback to a paragraph break if no sentence end is found.
                    const lastNewline = searchText.lastIndexOf('\n');
                    if (lastNewline > -1) {
                        return searchStart + lastNewline + 1;
                    }

                    // Fallback to a word boundary.
                    const lastSpace = searchText.lastIndexOf(' ');
                    if (lastSpace > -1) {
                        return searchStart + lastSpace + 1;
                    }

                    // Last resort: a hard cut if no other boundary is found.
                    return targetLength;
                }
            };




            // =============================================================================
            // VA INTEGRATION
            // =============================================================================
            /**
             * Manages the application's lifecycle and communication with the hosting
             * SAS Visual Analytics (VA) environment. It handles initializing the connection,
             * receiving parameters from the VA report, and triggering data-fetching operations.
             */
            const VAIntegration = {
                /**
                 * Extracts and maps known parameters from the VA message object into a
                 * structured object for easier access throughout the application.
                 * @param {object} vaMsgObj - The message object received from VA, which contains
                 *   a `parameters` array.
                 * @returns {{alertId: string, openaiKey: string, sasUser: string, sasPass: string}}
                 *   An object containing the extracted parameters by name.
                 */
                extractParameters(vaMsgObj) {
                    const params = vaMsgObj?.parameters || [];
                    const indexes = CONFIG.PARAMETER_INDEXES;

                    // This mapping provides a stable, named interface to the ordered array of
                    // parameters sent by VA, making the code more readable and less fragile.
                    return {
                        alertId: Utils.getParamByIndex(params, indexes.alertId),
                        openaiKey: Utils.getParamByIndex(params, indexes.openaiKey),
                        sasUser: Utils.getParamByIndex(params, indexes.sasUser),
                        sasPass: Utils.getParamByIndex(params, indexes.sasPass)
                    };
                },

                /**
                 * The primary callback function that processes messages from VA.
                 * It extracts parameters, updates the application state, and initiates the
                 * main workflow of fetching and displaying files if all required parameters are present.
                 * @param {object} vaMsgObj - The message object received from the VA host.
                 */
                async handleVAMessage(vaMsgObj) {
                    const params = this.extractParameters(vaMsgObj);

                    // Security: Log parameter presence, but not the values of secrets like keys or passwords.
                    Utils.log('VA', 'Parameters received', {
                        alertId: params.alertId,
                        hasOpenAI: !!params.openaiKey,
                        sasUser: params.sasUser,
                        hasPass: !!params.sasPass
                    });

                    const paramStatus = [
                        `Alert ID: ${params.alertId || 'missing'}`,
                        `OpenAI Key: ${params.openaiKey ? 'present' : 'missing'}`,
                        `SAS User: ${params.sasUser || 'missing'}`,
                        `SAS Pass: ${params.sasPass ? 'present' : 'missing'}`
                    ].join('\n');

                    UIManager.updateOutput(`Received parameters:\n${paramStatus}`);

                    App.setCurrentParams(params);

                    // Invariant: All parameters must be present to proceed with fetching data.
                    // This prevents unnecessary API calls that are guaranteed to fail.
                    if (params.alertId && params.openaiKey && params.sasUser && params.sasPass) {
                        try {
                            const files = await APIService.fetchAlertFiles(
                                params.alertId,
                                params.sasUser,
                                params.sasPass
                            );

                            UIManager.populateFileList(files);
                            UIManager.appendOutput(`\nAPI Response: (${files.length} files)`);
                            App.preloadFirstFiles(files);

                            // Start polling for file updates now that we have a valid context.
                            App.startAutoRefresh();
                        } catch (error) {
                            UIManager.showError(error.message);
                        }
                    } else {
                        UIManager.appendOutput('\nMissing required parameters - cannot fetch files');
                        // Ensure any previous auto-refresh process is stopped.
                        App.stopAutoRefresh();
                    }
                },

                /**
                 * Initializes the connection to the VA environment.
                 * It sets up the data receive callback and includes a retry mechanism to handle
                 * cases where the application loads before the VA messaging framework is ready.
                 */
                initialize() {
                    const tryConnect = () => {
                        // Rationale: The `va.messagingUtil` object is injected into the window by the
                        // SAS VA environment. It may not be available immediately on page load.
                        // This check ensures we don't try to attach the listener before the host is ready.
                        if (window.va && va.messagingUtil && typeof va.messagingUtil.setOnDataReceivedCallback === 'function') {
                            va.messagingUtil.setOnDataReceivedCallback(this.handleVAMessage.bind(this));
                            Utils.log('VA', 'Listener attached successfully');
                            UIManager.updateOutput('VA listener attached, waiting for data...');
                        } else {
                            // If the VA framework is not ready, poll again after a configured interval.
                            Utils.log('VA', 'Not ready, retrying...');
                            UIManager.updateOutput('VA not ready, retrying...');
                            setTimeout(tryConnect, CONFIG.VA_RETRY_INTERVAL);
                        }
                    };

                    tryConnect();
                }
            };


            // =============================================================================
            // CHAT (document-grounded Q&A)
            // =============================================================================
            /**
             * Manages the interactive chat feature for document-grounded question and answer.
             * It handles the chat UI, maintains separate conversation threads for each document,
             * constructs prompts for the AI, and processes streaming responses.
             */
            const Chat = {
                // State flag to prevent concurrent API requests.
                _busy: false,
                // A cache for frequently accessed DOM elements.
                els: {},

                /**
                 * Stores separate chat histories (threads) for each document context.
                 * @type {Map<string, Array<{role: 'user'|'bot', html: string, plain?: string}>>}
                 * Key: A unique identifier for the document context (e.g., "alertId:fileId").
                 * Value: An array of message objects representing the conversation.
                 */
                _threads: new Map(),
                /**
                 * REVIEW: This property appears to be unused. The streaming logic in `handleSend`
                 * uses a temporary `botBubble` variable instead of this map. This could be
                 * a remnant of a previous implementation.
                 */
                _lastBotNodeByKey: new Map(),

                /**
                 * Generates a unique key for the current chat context.
                 * The key is a combination of the alert ID and the selected file ID.
                 * @returns {string|null} The unique key, or null if no context is available.
                 */
                currentKey() {
                    const a = App._currentParams?.alertId ?? 'GLOBAL';
                    const f = App.getSelectedFileId?.() ?? null;
                    return f ? `${a}:${f}` : null;
                },

                /**
                 * Renders the chat history for a given context key into the message display area.
                 * If no thread exists for the key, it seeds a new one with a welcome message.
                 * @param {string} [key=this.currentKey()] - The context key for the thread to render.
                 */
                renderThread(key = this.currentKey()) {
                    if (!this.els.msgs) return;
                    this.els.msgs.innerHTML = '';
                    if (!key) return;

                    let arr = this._threads.get(key);
                    if (!arr) {
                        // Seed a new thread with a default welcome message for a better user experience.
                        arr = [{ role: 'bot', html: "Hi! Ask me anything about the currently selected document." }];
                        this._threads.set(key, arr);
                    }
                    for (const m of arr) this.addMsg(m.role, m.html);
                    this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                },

                /**
                 * Appends a new message to a specific chat thread's history.
                 * @param {'user'|'bot'} role - The role of the message author.
                 * @param {string} html - The HTML content of the message.
                 * @param {string} [key=this.currentKey()] - The context key for the thread.
                 * @param {string} [plain=''] - The plain text version of the content, for prompt history.
                 */
                appendToThread(role, html, key = this.currentKey(), plain = '') {
                    if (!key) return;
                    const arr = this._threads.get(key) ?? [];
                    arr.push({ role, html, plain });
                    this._threads.set(key, arr);
                },

                /**
                 * Initializes the Chat module: caches DOM elements and sets up all event listeners.
                 */
                init() {
                    this.els = {
                        toggle: document.getElementById(CONFIG.ELEMENTS.viewToggle),
                        card: document.querySelector('.card'),
                        input: document.getElementById(CONFIG.ELEMENTS.chatText),
                        send: document.getElementById(CONFIG.ELEMENTS.chatSendBtn),
                        msgs: document.getElementById(CONFIG.ELEMENTS.chatMessages),
                        title: document.getElementById('title'),
                        subtitle: document.querySelector('.subtitle')
                    };

                    // Helper to update the main card header based on the current view (Summary or Chat).
                    this.setHeader = (showChat) => {
                        const h = CONFIG.HEADINGS[showChat ? 'chat' : 'summary'];
                        if (this.els.title) this.els.title.textContent = h.title;
                        if (this.els.subtitle) this.els.subtitle.textContent = h.subtitle;
                        document.title = h.title; // Also update the browser tab title.
                    };

                    this.refreshSend();

                    this.setHeader(this.els.card.classList.contains('show-chat'));
                    if (this.els.card.classList.contains('show-chat')) {
                        this.renderThread(this.currentKey());
                    }


                    // --- Event Listeners ---
                    this.els.send.addEventListener('click', () => this.handleSend());
                    this.els.input.addEventListener('input', () => this.refreshSend());
                    this.els.input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.handleSend(); } });

                    // Handles toggling between the "Summary" and "Chat" views.
                    this.els.toggle.addEventListener('click', () => {
                        const showChat = !this.els.card.classList.contains('show-chat');
                        this.els.card.classList.toggle('show-chat', showChat);
                        this.els.toggle.setAttribute('aria-checked', showChat ? 'true' : 'false');
                        this.setHeader(showChat);
                        // When switching to chat view, render the appropriate conversation thread.
                        if (showChat) this.renderThread(this.currentKey());

                    });
                },

                /**
                 * Updates the enabled/disabled state of the "Send" button based on application state.
                 */
                refreshSend() {
                    // Invariants: To send a message, the API must not be busy, an API key must be
                    // present, a document must be loaded, and the input field must have text.
                    const hasKey = !!App._currentParams?.openaiKey;
                    const hasDoc = !!App._currentCleanedText;
                    const hasText = (this.els.input?.value.trim().length > 0);
                    if (this.els.send) this.els.send.disabled = this._busy || !(hasKey && hasDoc && hasText);
                },

                /**
                 * Creates a message bubble element and appends it to the chat display.
                 * @param {'user'|'bot'} role - The role of the message author.
                 * @param {string} html - The HTML content to render inside the bubble.
                 * @returns {HTMLElement} The created bubble element.
                 */
                addMsg(role, html) {
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    bubble.innerHTML = html;
                    wrap.appendChild(bubble);
                    this.els.msgs.appendChild(wrap);
                    this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                    return bubble;
                },

                /**
                 * Displays a "Thinking..." indicator and returns a function to remove it.
                 * @returns {{bubble: HTMLElement, stop: function():void}}
                 *   An object containing the
                 *   indicator's DOM element and a function to remove it.
                 */
                thinking() {
                    const bubble = this.addMsg('bot', '<span class="typing">Thinking<span class="dots"><i></i><i></i><i></i></span></span>');
                    return { bubble, stop: () => { bubble.parentElement?.remove(); } };
                },

                /**
                 * Constructs the full system prompt for the AI based on the user's question,
                 * the document content, and the recent conversation history.
                 * @param {string} userText - The user's latest question.
                 * @param {string} docText - The text content of the current document.
                 * @returns {string} The fully-formed prompt to be sent to the AI.
                 */
                buildPrompt(userText, docText) {
                    let processedText = docText || '';
                    const isMulti = processedText.startsWith('[[MULTI_DOC]]') || processedText.includes('==== [DOC ');

                    // Rationale: Apply character limits to the document context to avoid exceeding
                    // the AI model's context window, which would result in an error.
                    if (isMulti) {
                        const CHARS_PER_DOC_CHAT = 5000, MAX_CHARS_CHAT = 50000;
                        processedText = APIService.clipMultiDocuments(processedText, CHARS_PER_DOC_CHAT, MAX_CHARS_CHAT);
                    } else {
                        const MAX_SINGLE_DOC_CHAT = 24000;
                        if (processedText.length > MAX_SINGLE_DOC_CHAT) {
                            const clipPoint = APIService.findSentenceBoundary(processedText, MAX_SINGLE_DOC_CHAT);
                            processedText = processedText.slice(0, clipPoint) + '\n[...document trimmed for chat context]';
                        }
                    }

                    const cleaned = Utils.cleanTextForLLM(processedText, { maxConsecutiveNewlines: 2 });
                    const history = this.buildHistoryBlock(this.currentKey(), 3);

                    // This structure is a form of "prompt engineering" designed to guide the AI.
                    // It clearly separates the system instructions, conversation history, the
                    // grounding document, and the user's current question.
                    return [
                        "SYSTEM:",
                        "You are a concise assistant answering questions ONLY using the provided Document content.",
                        "Use the Conversation Context only for continuity; if context conflicts with the Document, the Document wins.",
                        "If the answer is not in the Document, say so plainly. Keep answers brief and clear.",
                        "",
                        history ? history : "",
                        history ? "" : "",           // keep spacing consistent
                        "DOCUMENT:",
                        cleaned,
                        "",
                        "USER QUESTION:",
                        userText,
                        "",
                        "ASSISTANT:"
                    ].join("\n");
                },

                /**
                 * Handles the entire process of sending a user's message, including updating the UI,
                 * calling the AI service with a streaming response, and rendering the reply.
                 */
                async handleSend() {
                    const text = this.els.input.value.trim();
                    if (!text) return;

                    const key = this.currentKey();

                    // 1. Add the user's message to the UI and the conversation history.
                    const userHtml = Utils.escapeHtml(text).replace(/\n/g, '<br>');
                    this.addMsg('user', userHtml);
                    this.appendToThread('user', userHtml, key, text);

                    // 2. Reset UI and enter busy state.
                    this.els.input.value = '';
                    this._busy = true; this.refreshSend();

                    // 3. Show a "Thinking..." indicator, which will be replaced by the streamed response.
                    const think = this.thinking();
                    await new Promise(r => requestAnimationFrame(r));

                    let buf = ''; // Buffer for the streaming response text.
                    let raf = null; // requestAnimationFrame handle for performance.
                    let final = ''; // Stores the final, non-streamed result if needed.

                    // 4. Create an empty placeholder in the history for the bot's reply.
                    // This will be filled as the response streams in.
                    this.appendToThread('bot', '', key, '');
                    const botIdx = this._threads.get(key).length - 1;

                    // 5. Set up the streaming handler.
                    const botBubble = think.bubble; // The "Thinking..." bubble DOM node.
                    const flush = () => {
                        // This function updates the bot's bubble with the latest buffered text.
                        // It's wrapped in requestAnimationFrame to prevent UI thrashing.
                        const safe = Utils.escapeHtml(buf).replace(/\n/g, '<br>');
                        botBubble.innerHTML = safe;
                        // Update the history array with the latest content.
                        const arr = this._threads.get(key);
                        if (arr && arr[botIdx]) {
                            arr[botIdx].html = safe;
                            arr[botIdx].plain = buf; // Also store plain text for future prompts.
                        }
                        raf = null;
                        this.els.msgs.scrollTop = this.els.msgs.scrollHeight;
                    };
                    try {
                        const params = App._currentParams || {};
                        if (!params.openaiKey) throw new Error('Missing OpenAI key');
                        if (!App._currentCleanedText) throw new Error('Select a file first; no document loaded');

                        // 6. Build the prompt and call the API with the streaming callback.
                        const prompt = this.buildPrompt(text, App._currentCleanedText);
                        final = await APIService.callOpenAIChat(
                            prompt, params.openaiKey, CONFIG.OPENAI.MODEL,
                            // This `onDelta` callback is the heart of the streaming logic.
                            // It appends chunks to the buffer and schedules a UI update.
                            (_d, full) => { buf = full; if (!raf) raf = requestAnimationFrame(flush); }
                        );

                        // Final flush to ensure the last chunk is rendered.
                        if (raf) { cancelAnimationFrame(raf); raf = null; }
                        if (!buf.trim()) { buf = final; flush(); } // Handle non-streaming edge case.
                    } catch (e) {
                        // Display errors directly in the chat bubble for user visibility.
                        buf = `Sorry, I couldn't complete that: ${e.message}`;
                        flush();
                        console.error('[chat]', e);
                    } finally {
                        // 7. Clean up and exit busy state.
                        this._busy = false; this.refreshSend();
                    }
                },
                /**
                 * Constructs the conversation history block for the system prompt.
                 * It retrieves the last few user/bot exchanges from the thread history.
                 * @param {string} [key=this.currentKey()] - The context key for the thread.
                 * @param {number} [maxPairs=3] - The maximum number of Q&A pairs to include.
                 * @returns {string} A formatted string of the recent conversation history.
                 */
                buildHistoryBlock(key = this.currentKey(), maxPairs = 3) {
                    const arr = this._threads.get(key) || [];
                    if (!arr.length) return '';

                    // Prepare the history array: remove the ephemeral empty bot bubble that was
                    // just added, and the user message we are currently processing.
                    const filtered = arr.filter((m, i) => !(m.role === 'bot' && !m.html))
                        .slice(); // shallow copy
                    if (filtered.length && filtered[filtered.length - 1].role === 'user') {
                        filtered.pop();
                    }

                    // Walk backward through the history, collecting user/bot message pairs.
                    const pairs = [];
                    for (let i = filtered.length - 1; i >= 1 && pairs.length < maxPairs; i--) {
                        const b = filtered[i], u = filtered[i - 1];
                        if (b.role === 'bot' && u.role === 'user') {
                            pairs.unshift({
                                uq: u.plain || DocumentSummarizerApp._modules.Utils.stripHtml(u.html),
                                ar: b.plain || DocumentSummarizerApp._modules.Utils.stripHtml(b.html)
                            });
                            i--; // Decrement again to skip the user message we just consumed.
                        }
                    }

                    if (!pairs.length) return '';

                    let out = `CONVERSATION CONTEXT (last ${pairs.length} Q/A turns):\n`;
                    pairs.forEach((p, idx) => {
                        out += `Q${idx + 1}: ${p.uq}\nA${idx + 1}: ${p.ar}\n`;
                    });
                    return out.trim();
                }
            };


            // =============================================================================
            // MAIN APPLICATION
            // =============================================================================
            /**
             * The main application controller. It orchestrates the different modules (UI, API, VA),
             * manages the central application state (caches, current selections), and handles
             * the core business logic for file selection, preloading, and summarization.
             */
            const App = {
                // Caches parameters received from VA for use in subsequent API calls.
                _currentParams: null,
                // In-memory cache for cleaned text content of files. { key: content }
                _fileCache: new Map(),
                // In-memory cache for generated summaries. { key: summaryHtml }
                _summaryCache: new Map(),
                // Holds the cleaned text content of the currently selected file/document set.
                _currentCleanedText: null,
                // Holds the interval ID for the file list auto-refresh timer.
                _refreshInterval: null,
                // A set of cache keys for files currently being fetched to prevent duplicate requests.
                _inflightLoads: new Set(),
                // A unique symbol to identify and abort outdated preloading operations.
                _preloadToken: null,
                // A set of keys for files currently being summarized to manage UI state.
                _activeSummaries: new Set(),

                /**
                 * Initializes all application modules, sets up global event listeners,
                 * and establishes the connection with the VA environment.
                 */
                init() {
                    Utils.log('APP', 'Initializing Document Summarizer App');

                    try {
                        // Check for presence of external libraries and log status.
                        if (typeof pdfjsLib !== 'undefined') {
                            Utils.log('APP', 'PDF.js loaded successfully');
                        } else {
                            Utils.log('APP', 'Warning: PDF.js not loaded - PDF support will be limited');
                        }

                        UIManager.setupEventListeners();
                        VAIntegration.initialize();
                        Chat.init();

                        // Expose methods to the global scope for legacy or cross-module communication.
                        window.DocumentSummarizerApp = window.DocumentSummarizerApp || {};
                        window.DocumentSummarizerApp._onFileSelected = this.handleFileSelection.bind(this);
                        window.DocumentSummarizerApp._onSummarizeClick = this.handleSummarize.bind(this);

                        window.DocumentSummarizerApp._updateBtn =
                            this._updateSummarizeButtonForCurrentSelection.bind(this);

                        // Rationale: Perform cleanup on page exit to clear timers and cached tokens,
                        // preventing memory leaks and unnecessary open connections.
                        window.addEventListener('beforeunload', () => {
                            this.stopAutoRefresh();
                            APIService.clearToken();
                            Utils.log('APP', 'Cleanup completed on page unload');
                        });

                    } catch (error) {
                        Utils.log('APP', 'Initialization error', error);
                        UIManager.updateOutput(`Error: ${error.message}`);
                    }
                },

                /**
                 * Fetches document content and displays it in a modal dialog.
                 * Handles both single documents and the special "All Documents" case.
                 * @param {string} fileId - The ID of the file to display, or the special ID for all documents.
                 * @param {string} [fileName='Document'] - The name of the document for the modal title.
                 */
                async openContentModal(fileId, fileName = 'Document') {
                    try {
                        const { alertId, sasUser, sasPass } = this._currentParams || {};
                        if (!alertId || !sasUser || !sasPass) {
                            this._currentCleanedText = null;
                            this._updateSummarizeButtonForCurrentSelection();
                            return; // Bail gracefully if essential parameters are missing.
                        }
                        const modal = document.getElementById('contentModal');
                        const pre = document.getElementById('modalFileContent');
                        const title = document.getElementById('contentModalTitle');

                        if (!modal || !pre) return;

                        if (title) title.textContent = fileName;

                        let text = '';
                        // Special path: If "All Documents" is selected, concatenate the text of all files.
                        if (String(fileId) === DocumentSummarizerApp._modules.CONFIG.SPECIAL.ALL_ID) {
                            const parts = [];
                            for (const f of UIManager._allFiles) {
                                const fid = String(f.id || f.fileId || '');
                                if (!fid) continue;
                                const key = `${String(alertId)}:${fid}`;
                                // Use cached content if available, otherwise fetch, clean, and cache it.
                                if (this._fileCache.has(key)) {
                                    parts.push(this._fileCache.get(key));
                                } else {
                                    const fd = await DocumentSummarizerApp._modules.APIService.getFileContent(alertId, fid, sasUser, sasPass);
                                    const ex = await DocumentSummarizerApp._modules.APIService.extractTextFromFile(fd);
                                    const cl = DocumentSummarizerApp._modules.Utils.cleanTextForLLM(ex, { maxConsecutiveNewlines: 2 });
                                    this._fileCache.set(key, cl);
                                    parts.push(cl);
                                }
                            }
                            text = parts.join('\n\n');
                        } else {
                            // Standard path for a single document.
                            const cacheKey = `${String(alertId)}:${String(fileId)}`;
                            if (this._fileCache.has(cacheKey)) {
                                text = this._fileCache.get(cacheKey);
                            } else {
                                const fileData = await DocumentSummarizerApp._modules.APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                                const extracted = await DocumentSummarizerApp._modules.APIService.extractTextFromFile(fileData);
                                text = DocumentSummarizerApp._modules.Utils.cleanTextForLLM(extracted, { maxConsecutiveNewlines: 2 });
                                this._fileCache.set(cacheKey, text);
                                // Simple FIFO cache eviction policy.
                                if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);
                            }
                        }

                        pre.textContent = text || '[No text content]';

                        modal.hidden = false;
                        document.body.classList.add('modal-open');

                        // Wire up modal closing events only once for efficiency.
                        if (!this._modalWired) {
                            this._modalWired = true;
                            modal.addEventListener('click', (e) => {
                                if (e.target?.dataset?.close === 'true') this.closeContentModal();
                            });
                            const closeBtn = document.getElementById('contentModalClose');
                            if (closeBtn) closeBtn.addEventListener('click', () => this.closeContentModal());
                            window.addEventListener('keydown', (e) => {
                                if (e.key === 'Escape' && !modal.hidden) this.closeContentModal();
                            });
                        }
                    } catch (err) {
                        console.error('[modal] open failed', err);
                        const pre = document.getElementById('modalFileContent');
                        if (pre) pre.textContent = `Error loading content: ${err.message}`;
                        const modal = document.getElementById('contentModal');
                        if (modal) { modal.hidden = false; document.body.classList.add('modal-open'); }
                    }
                },

                /**
                 * Closes the content preview modal.
                 */
                closeContentModal() {
                    const modal = document.getElementById('contentModal');
                    if (modal) modal.hidden = true;
                    document.body.classList.remove('modal-open');
                },

                /**
                 * Creates a consistent key for state management (caches, active summaries).
                 * @private
                 */
                _key(alertId, fileId) {
                    return `${String(alertId ?? 'GLOBAL')}:${String(fileId ?? '')}`;
                },

                /**
                 * Manages the UI state of the "Summarize" button based on the current selection
                 * and whether a summary for that selection is already in progress.
                 * @private
                 */
                _updateSummarizeButtonForCurrentSelection() {
                    const btn = document.getElementById(CONFIG.ELEMENTS.summarizeBtn);
                    if (!btn) return;

                    const fileId = this.getSelectedFileId();
                    const alertId = this._currentParams?.alertId;

                    const isSummarizingThisFile =
                        !!fileId && !!alertId && this._activeSummaries.has(this._key(alertId, fileId));

                    const canSummarizeThisFile =
                        !!this._currentCleanedText && !!this._currentParams?.openaiKey && !!fileId;

                    // The button's state is driven purely by the state of the currently selected file.
                    btn.disabled = !canSummarizeThisFile || isSummarizingThisFile;
                    btn.classList.toggle('loading', isSummarizingThisFile);
                    btn.setAttribute('aria-busy', isSummarizingThisFile ? 'true' : 'false');

                    // Also update the file list to show a loading indicator on items being summarized.
                    if (alertId) {
                        document.querySelectorAll('.file').forEach(el => {
                            const fid = el.dataset.fileId;
                            const summarizing = this._activeSummaries.has(this._key(alertId, fid));
                            el.classList.toggle('is-summarizing', summarizing);
                        });
                    }
                },

                /**
                 * Starts a periodic auto-refresh to fetch the latest list of files.
                 */
                startAutoRefresh() {
                    if (!CONFIG.AUTO_REFRESH.ENABLED || this._refreshInterval) return;

                    this._refreshInterval = setInterval(async () => {
                        if (!this._currentParams) return;

                        const { alertId, sasUser, sasPass } = this._currentParams;

                        if (alertId && sasUser && sasPass) {
                            try {
                                Utils.log('AUTO_REFRESH', 'Fetching updated file list');

                                const files = await APIService.fetchAlertFiles(
                                    alertId,
                                    sasUser,
                                    sasPass
                                );

                                UIManager.populateFileList(files);

                                Utils.log('AUTO_REFRESH', `Updated file list: ${files.length} files`);
                            } catch (error) {
                                Utils.log('AUTO_REFRESH', 'Refresh failed', error);
                                // Rationale: Auto-refresh failures should be silent to avoid bothering the user
                                // with transient network errors.
                            }
                        }
                    }, CONFIG.AUTO_REFRESH.INTERVAL);

                    Utils.log('AUTO_REFRESH', `Started auto-refresh every ${CONFIG.AUTO_REFRESH.INTERVAL}ms`);
                },

                /**
                 * Stops the auto-refresh timer.
                 */
                stopAutoRefresh() {
                    if (this._refreshInterval) {
                        clearInterval(this._refreshInterval);
                        this._refreshInterval = null;
                        Utils.log('AUTO_REFRESH', 'Stopped auto-refresh');
                    }
                },

                /**
                 * Proactively fetches and caches the content of the first few files in the list
                 * to improve perceived performance when a user selects them.
                 * @param {Array<Object>} files - The list of files to consider for preloading.
                 */
                async preloadFirstFiles(files) {
                    if (!CONFIG.PRELOAD.ENABLED) return;
                    if (!this._currentParams) return;

                    const { alertId, sasUser, sasPass } = this._currentParams;
                    if (!alertId || !sasUser || !sasPass) return;

                    const list = (files && files.length ? files : UIManager._allFiles) || [];
                    if (!list.length) return;

                    // Rationale: The token is used to gracefully abort an ongoing preload operation
                    // if a new one is triggered (e.g., by a file list refresh), preventing race conditions.
                    const token = Symbol('preload');
                    this._preloadToken = token;

                    const toPreload = list.slice(0, CONFIG.PRELOAD.COUNT);

                    for (const f of toPreload) {
                        if (this._preloadToken !== token) {
                            Utils.log('PRELOAD', 'Aborted previous preload wave');
                            return;
                        }

                        const fileId = String(f.id || f.fileId || '');
                        if (!fileId) continue;

                        const cacheKey = `${String(alertId)}:${fileId}`;

                        if (this._fileCache.has(cacheKey) || this._inflightLoads.has(cacheKey)) {
                            continue;
                        }

                        try {
                            this._inflightLoads.add(cacheKey);

                            const fileData = await APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                            const extracted = await APIService.extractTextFromFile(fileData);
                            const cleaned = Utils.cleanTextForLLM(extracted, {
                                removeExtraSpaces: true,
                                removeSpecialChars: true,
                                normalizeWhitespace: true,
                                removeEmptyLines: true,
                                trimLines: true,
                                maxConsecutiveNewlines: 2
                            });

                            this._fileCache.set(cacheKey, cleaned);
                            if (this._fileCache.size > 10) {
                                const firstKey = this._fileCache.keys().next().value;
                                this._fileCache.delete(firstKey);
                            }

                            Utils.log('PRELOAD', `Cached file ${fileId}`);
                        } catch (e) {
                            Utils.log('PRELOAD', `Failed to preload ${fileId}`, e);
                            // Rationale: Preloading failures should be silent as they are a non-critical
                            // background optimization.
                        } finally {
                            this._inflightLoads.delete(cacheKey);
                        }

                        if (CONFIG.PRELOAD.DELAY) {
                            await new Promise(r => setTimeout(r, CONFIG.PRELOAD.DELAY));
                        }
                    }

                    Utils.log('PRELOAD', 'Preload finished');
                },

                /**
                 * Updates the application's state with the current parameters from VA.
                 * @param {object} params - The structured parameter object.
                 */
                setCurrentParams(params) {
                    this._currentParams = params;
                },

                /**
                 * Handles the logic for when a user selects a file from the list.
                 * This function is the main entry point for loading and processing document content.
                 * @param {string} fileId - The ID of the selected file.
                 */
                async handleFileSelection(fileId) {
                    const { alertId, sasUser, sasPass } = this._currentParams;

                    this._currentCleanedText = null;
                    this._updateSummarizeButtonForCurrentSelection();

                    // If a summary for the selected file exists in the cache, display it.
                    const baseKey = `${String(alertId)}:${String(fileId)}:`
                    const summaryEl = document.getElementById(CONFIG.ELEMENTS.summaryContent);
                    if (this._summaryCache) {
                        const matchKey = [...this._summaryCache.keys()].find(k => k.startsWith(baseKey));
                        if (matchKey && summaryEl) { summaryEl.innerHTML = SANITIZE(this._summaryCache.get(matchKey)); }
                        else if (summaryEl) { summaryEl.innerHTML = '<span style="color: var(--muted)">AI summary will appear here...</span>'; }
                    }

                    try {
                        // Special Path: Handle the "All Documents" selection.
                        if (String(fileId) === CONFIG.SPECIAL.ALL_ID) {
                            const parts = [];
                            for (const f of UIManager._allFiles) {
                                const fid = String(f.id || f.fileId || '');
                                if (!fid) continue;
                                const cacheKey = `${alertId}:${fid}`;

                                let cleaned;
                                if (this._fileCache.has(cacheKey)) {
                                    cleaned = this._fileCache.get(cacheKey);
                                } else {
                                    const fileData = await APIService.getFileContent(alertId, fid, sasUser, sasPass);
                                    const extracted = await APIService.extractTextFromFile(fileData);
                                    cleaned = Utils.cleanTextForLLM(extracted, {
                                        removeExtraSpaces: true, removeSpecialChars: true, normalizeWhitespace: true,
                                        removeEmptyLines: true, trimLines: true, maxConsecutiveNewlines: 2
                                    });
                                    this._fileCache.set(cacheKey, cleaned);
                                    if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);
                                }

                                if (cleaned) parts.push(cleaned);
                            }

                            // Rationale: Construct a special combined text payload with markers and a table
                            // of contents that the AI can use to understand the multi-document structure.
                            const lines = UIManager._allFiles.map((f, i) => {
                                const name = (f.name || f.fileName || f.id || `Document ${i + 1}`).toString();
                                return `- [DOC ${i + 1}] ${name}`;
                            });
                            const combined = [
                                '[[MULTI_DOC]]', // Marker for the API service to select the multi-document prompt.
                                'INPUT CONTAINS MULTIPLE DOCUMENTS',
                                'TABLE OF CONTENTS:',
                                ...lines,
                                '',
                                ...UIManager._allFiles.map((f, i) => {
                                    const name = (f.name || f.fileName || f.id || `Document ${i + 1}`).toString();
                                    const fid = String(f.id || f.fileId || '');
                                    const cacheKey = `${alertId}:${fid}`;
                                    const text = this._fileCache.get(cacheKey) || '';
                                    return `==== [DOC ${i + 1}] ${name} ====
${text}`;
                                })
                            ].join('\n');

                            this._currentCleanedText = combined;
                            this._updateSummarizeButtonForCurrentSelection();

                            // If in chat mode, switch the chat context to the new selection.
                            if (document.querySelector('.card')?.classList.contains('show-chat')) {
                                Chat.renderThread(Chat.currentKey());
                            }
                            Chat.refreshSend();
                            return; // Stop here to avoid falling through to the single-file path.
                        }

                        // Standard Path: Handle a single file selection.
                        const cacheKey = `${alertId}:${fileId}`;
                        if (this._fileCache && this._fileCache.has(cacheKey)) {
                            this._currentCleanedText = this._fileCache.get(cacheKey);
                            this._updateSummarizeButtonForCurrentSelection();
                            if (document.querySelector('.card')?.classList.contains('show-chat')) {
                                Chat.renderThread(Chat.currentKey());
                            }
                            Chat.refreshSend();
                            return;
                        }

                        const fileData = await APIService.getFileContent(alertId, fileId, sasUser, sasPass);
                        const extractedText = await APIService.extractTextFromFile(fileData, (status) => {
                        });
                        const cleanedText = Utils.cleanTextForLLM(extractedText, {
                            removeExtraSpaces: true, removeSpecialChars: true, normalizeWhitespace: true,
                            removeEmptyLines: true, trimLines: true, maxConsecutiveNewlines: 2
                        });

                        this._fileCache.set(cacheKey, cleanedText);
                        if (this._fileCache.size > 10) this._fileCache.delete(this._fileCache.keys().next().value);

                        this._currentCleanedText = cleanedText;
                        this._updateSummarizeButtonForCurrentSelection();
                        if (document.querySelector('.card')?.classList.contains('show-chat')) {
                            Chat.renderThread(Chat.currentKey());
                        }
                        Chat.refreshSend();

                    } catch (error) {
                        Utils.log('APP', 'File loading failed', error);
                        this._currentCleanedText = null;
                        this._updateSummarizeButtonForCurrentSelection();
                    }
                },


                /**
                 * Retrieves the ID of the currently selected file from the UIManager.
                 * @returns {string|null} The selected file ID.
                 */
                getSelectedFileId() {
                    // Defers to the UIManager as the single source of truth for UI state.
                    return UIManager._selectedFileId || null;
                },
                /**
                 * Handles the click event for the "Summarize" button.
                 * Manages caching, UI state, and calls the API to get a summary.
                 */
                async handleSummarize() {
                    if (!this._currentCleanedText) {
                        alert('No document content to summarize');
                        return;
                    }
                    if (!this._currentParams || !this._currentParams.openaiKey) {
                        alert('OpenAI API key is required for summarization');
                        return;
                    }

                    const fileId = String(this.getSelectedFileId() ?? '');
                    if (!fileId) {
                        alert('No file selected');
                        return;
                    }
                    const alertId = String(this._currentParams?.alertId ?? 'GLOBAL');
                    const key = this._key(alertId, fileId);

                    // Create a cache key that includes the text length as a fingerprint.
                    // This invalidates the cache if the document content changes.
                    const fp = String(this._currentCleanedText.length);
                    const summaryCacheKey = `${alertId}:${fileId}:${fp}`;
                    const summaryEl = document.getElementById(CONFIG.ELEMENTS.summaryContent);

                    if (this._summaryCache.has(summaryCacheKey)) {
                        const cachedSummary = this._summaryCache.get(summaryCacheKey);
                        if (summaryEl) summaryEl.innerHTML = SANITIZE(cachedSummary);
                        Utils.log('APP', 'Using cached summary');
                        return;
                    }

                    // De-duplication: Prevent starting a new summary if one for the same file is already running.
                    if (this._activeSummaries.has(key)) {
                        Utils.log('APP', `Already summarizing ${key}`);
                        return;
                    }

                    this._activeSummaries.add(key);
                    this._updateSummarizeButtonForCurrentSelection();

                    try {
                        // Show a skeleton loader, but only if the user is still viewing the file being summarized.
                        const isStillSelected = this._key(this._currentParams?.alertId, this.getSelectedFileId()) === key;
                        if (summaryEl && isStillSelected) {
                            summaryEl.innerHTML =
                                '<div class="skel" aria-hidden="true">' +
                                '<div class="line" style="width:64%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:88%"></div>' +
                                '<div class="line" style="width:64%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:26%"></div>' +
                                '<div class="line" style="width:0%"></div>' +
                                '<div class="line" style="width:77%"></div>' +
                                '<div class="line" style="width:87%"></div>' +
                                '<div class="line" style="width:82%"></div>' +
                                '</div>';
                        }

                        const summary = await APIService.callOpenAI(
                            this._currentCleanedText,
                            this._currentParams.openaiKey,
                            CONFIG.OPENAI.MODEL,
                            (delta, full) => {
                                // Rationale: Live-stream the summary text, but only update the UI
                                // if the user hasn't navigated away to a different file.
                                const selectedKey = this._key(this._currentParams?.alertId, this.getSelectedFileId());
                                if (summaryEl && selectedKey === key) {
                                    summaryEl.innerHTML = SANITIZE(full);
                                }
                            }
                        );

                        const stillSelected = this._key(this._currentParams?.alertId, this.getSelectedFileId()) === key;
                        if (summaryEl && stillSelected) {
                            const safeFinal = SANITIZE(summary);
                            summaryEl.innerHTML = safeFinal;
                            this._summaryCache.set(summaryCacheKey, safeFinal);
                        }

                        if (this._summaryCache.size > 15) {
                            const firstKey = this._summaryCache.keys().next().value;
                            this._summaryCache.delete(firstKey);
                        }

                        Utils.log('APP', `Summary cached for file: ${fileId}`);
                    } catch (error) {
                        Utils.log('APP', 'Summarization failed', error);
                        const selectedKey = this._key(this._currentParams?.alertId, this.getSelectedFileId());
                        if (summaryEl && selectedKey === key) {
                            summaryEl.textContent = `Error generating summary: ${error.message}`;
                        }
                    } finally {
                        // Always clear the busy flag for this file and refresh the UI state.
                        this._activeSummaries.delete(key);
                        this._updateSummarizeButtonForCurrentSelection();
                    }

                }
            };


            // =============================================================================
            // PUBLIC API
            // =============================================================================
            /**
             * Exposes a public interface for the DocumentSummarizerApp module.
             * This allows external scripts to interact with the application in a controlled way,
             * for instance, to initiate it or use its utility functions.
             */
            return {
                /** Kicks off the entire application. */
                init: App.init.bind(App),
                /** Returns the ID of the currently selected file. */
                getSelectedFileId: App.getSelectedFileId.bind(App),

                /** Programmatically retrieves a SAS access token. */
                async getSASToken(username, password) {
                    return APIService.getSASToken(username, password);
                },
                /** Clears the cached SAS access token. */
                clearToken() {
                    return APIService.clearToken();
                },
                /** Fetches the raw content of a specific file. */
                async getFileContent(alertId, fileId, username, password) {
                    return APIService.getFileContent(alertId, fileId, username, password);
                },
                /** Extracts text from a file based on its content type. */
                async extractTextFromFile(fileData) {
                    return APIService.extractTextFromFile(fileData);
                },
                /** Extracts text from a PDF ArrayBuffer. */
                async extractTextFromPDF(arrayBuffer, onProgress = null) {
                    return APIService.extractTextFromPDF(arrayBuffer, onProgress);
                },
                /** Cleans and prepares text for optimal LLM processing. */
                cleanTextForLLM(text, options = {}) {
                    return Utils.cleanTextForLLM(text, options);
                },
                /**
                 * Internal modules exposed for debugging, testing, or advanced integration.
                 * @private
                 */
                _modules: {
                    Utils,
                    UIManager,
                    APIService,
                    VAIntegration,
                    CONFIG
                }
            };
        })();

        // =============================================================================
        // APPLICATION STARTUP
        // =============================================================================
        /**
         * This is the main entry point of the application.
         * Calling `init()` starts the application, sets up listeners, and prepares it
         * to receive data from the SAS Visual Analytics environment.
         */
        DocumentSummarizerApp.init();
    </script>
</body>

</html>

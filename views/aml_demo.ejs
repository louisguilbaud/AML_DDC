<!DOCTYPE html>
<html lang="en">

<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Alert Summarizer</title>
        <!-- SAS VA messaging utility for receiving data/parameters from Visual Analytics -->
        <script src="./javascripts/sas/util/messagingUtil.js"></script>
        <style>
                /*==========================================================
                  GLOBAL THEME TOKENS & BASE ELEMENTS
                  - CSS variables enable quick theming across the app.
                  - Avoid hardcoding colors elsewhere; prefer these tokens.
                ==========================================================*/
                :root {
                        --bg: #fff;
                        --fg: #1d1d1f;
                        --muted: #6e6e73;
                        --card: #fff;
                        --border: rgba(0, 0, 0, .08);
                        --primary: #0478CE;
                        --primary-press: #0366AF;
                        --content-indent: 14px;
                        --primary-soft: #E8F3FF;
                        --grey-soft: #fafafa;
                }

                * {
                        box-sizing: border-box
                }

                html,
                body {
                        height: 100%
                }

                body {
                        margin: 0;
                        background: var(--bg);
                        color: var(--fg);
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, system-ui
                }


                .container {
                        width: min(96vw, 1600px);
                        margin: 2vh auto 8vh;
                        padding: 0 24px;
                }

                .card {
                        background: var(--card);
                        border: 1px solid var(--border);
                        border-radius: 24px;
                        box-shadow: 0 1px 2px rgba(0, 0, 0, .04), 0 8px 30px rgba(0, 0, 0, .06);
                        padding: 32px;
                        display: grid;
                        gap: 18px
                }

                .header {
                        display: flex;
                        justify-content: space-between;
                        align-items: flex-start;
                        gap: 12px
                }

                h1 {
                        margin: 0 0 6px 0;
                        font-size: 28px;
                        font-weight: 650;
                        letter-spacing: -.02em
                }

                .subtitle {
                        margin: 0;
                        color: var(--muted);
                        font-size: 14px
                }

                .row {
                        display: flex;
                        gap: 10px;
                        align-items: center
                }

                button {
                        appearance: none;
                        border: none;
                        cursor: pointer;
                        font-family: inherit
                }

                /* Primary CTA button (e.g., Summarize, Send) */
                .btn-primary {
                        background: var(--primary);
                        color: #fff;
                        border-radius: 14px;
                        padding: 12px 18px;
                        font-size: 16px;
                        font-weight: 600;
                        box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
                        transition: transform .06s, box-shadow .2s, filter .2s
                }

                .btn-primary:hover {
                        filter: brightness(1.02)
                }

                .btn-primary:active {
                        transform: scale(.985)
                }

                .btn-primary:disabled {
                        opacity: .65;
                        cursor: not-allowed;
                        box-shadow: none
                }

                /* Secondary/neutral button (Clear/Save) */
                .btn-secondary {
                        background: var(--grey-soft);
                        color: var(--fg);
                        border-radius: 14px;
                        padding: 10px 16px;
                        font-size: 14px;
                        font-weight: 600
                }

                .btn-secondary:hover {
                        filter: brightness(.97)
                }

                .btn-secondary:active {
                        filter: brightness(.94)
                }

                /* Inline spinner used inside .btn-primary when loading */
                .spinner {
                        width: 16px;
                        height: 16px;
                        border: 2px solid rgba(255, 255, 255, .6);
                        border-top-color: #fff;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        display: none
                }

                @keyframes spin {
                        to {
                                transform: rotate(360deg)
                        }
                }

                /* Swap label <-> spinner while loading */
                .loading .spinner {
                        display: inline-block
                }

                .loading .labeltext {
                        display: none
                }

                /* Section label headers (Summary, Comments, Chat) */
                .label {
                        font-size: 12px;
                        text-transform: uppercase;
                        letter-spacing: .08em;
                        color: var(--muted);
                        margin-bottom: 8px;
                        padding-left: var(--content-indent);
                }

                /* A11y: Visually hidden but screen-reader accessible text */
                .sr-only {
                        position: absolute;
                        width: 1px;
                        height: 1px;
                        padding: 0;
                        margin: -1px;
                        overflow: hidden;
                        clip: rect(0, 0, 0, 0);
                        white-space: nowrap;
                        border: 0;
                }

                /* Compact select styled to match secondary buttons */
                .select-model {
                        background: var(--grey-soft);
                        color: var(--fg);
                        border: none;
                        border-radius: 14px;
                        padding: 10px 12px;
                        font-size: 14px;
                        font-weight: 600;
                }

                .select-model:disabled {
                        opacity: .65;
                        cursor: not-allowed;
                }

                /* LLM summary output container (can contain headings, lists) */
                .summary {
                        border: 1px solid var(--border);
                        border-radius: 14px;
                        background: var(--grey-soft);
                        padding: 14px;
                        min-height: 140px;
                        white-space: normal;
                        font-size: 14px
                }

                .summary h1 {
                        font-size: 24px;
                        margin: 0 0 8px
                }

                .summary h2 {
                        font-size: 18px;
                        margin: 14px 0 6px
                }

                .summary p {
                        margin: 6px 0
                }

                .summary ul {
                        margin: 6px 0 6px 18px;
                        padding-left: 14px
                }

                .summary li {
                        margin: 3px 0
                }

                /* Optional cutoff-date footnote appended by JS */
                .summary .cutoff {
                        margin-top: 10px;
                        font-size: 12px;
                        color: var(--muted)
                }

                /* Comment textarea (auto-resized via JS) */
                textarea {
                        width: 100%;
                        min-height: 120px;
                        padding: 14px 14px;
                        border-radius: 16px;
                        border: 1px solid rgba(0, 0, 0, .12);
                        background: #fff;
                        outline: none;
                        line-height: 1.5;
                        overflow: hidden;
                        resize: none
                }

                textarea:focus {
                        border-color: var(--primary-press);
                        box-shadow: 0 0 0 4px rgba(10, 132, 255, .12)
                }

                .caption {
                        font-size: 12px;
                        color: var(--muted)
                }

                /* Toast for lightweight notifications (saved/cleared) */
                .toast {
                        position: fixed;
                        left: 50%;
                        bottom: 24px;
                        transform: translateX(-50%) translateY(20px);
                        background: #111;
                        color: #fff;
                        padding: 10px 14px;
                        border-radius: 999px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
                        opacity: 0;
                        pointer-events: none;
                        transition: transform .35s, opacity .35s
                }

                .toast.show {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0)
                }

                /* "Working..." skeleton/loader composition */
                .working {
                        display: inline-flex;
                        align-items: center;
                        gap: 6px;
                        color: var(--muted);
                        font-weight: 600
                }

                .working .dots {
                        display: inline-flex;
                        gap: 4px;
                        margin-left: 2px
                }

                .working .dots i {
                        width: 6px;
                        height: 6px;
                        border-radius: 50%;
                        background: var(--muted);
                        opacity: .25;
                        animation: dotpulse 1s ease-in-out infinite
                }

                .working .dots i:nth-child(2) {
                        animation-delay: .2s
                }

                .working .dots i:nth-child(3) {
                        animation-delay: .4s
                }

                @keyframes dotpulse {

                        0%,
                        100% {
                                transform: translateY(0);
                                opacity: .25
                        }

                        50% {
                                transform: translateY(-3px);
                                opacity: 1
                        }
                }

                .skel {
                        display: grid;
                        gap: 8px;
                        margin-top: 10px
                }

                .skel .line {
                        height: 10px;
                        border-radius: 6px;
                        background: linear-gradient(90deg, #ececec, #f7f7f7, #ececec);
                        background-size: 200% 100%;
                        animation: shimmer 1.2s linear infinite
                }

                @keyframes shimmer {
                        0% {
                                background-position: 200% 0
                        }

                        100% {
                                background-position: -200% 0
                        }
                }

                #charCount {
                        margin-left: var(--content-indent);
                }

                .header>div:first-child {
                        padding-left: var(--content-indent);
                }

                /*==========================================================
                  CHAT UI
                  - Simple inline messenger: messages area + composer.
                ==========================================================*/
                .chat {
                        border: 1px solid var(--border);
                        border-radius: 14px;
                        background: var(--grey-soft);
                        padding: 14px;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                }

                .chat-messages {
                        min-height: 273px;
                        max-height: clamp(360px, 55vh, 720px);
                        overflow: auto;
                        display: grid;
                        gap: 10px;
                        padding-right: 4px;
                        align-content: start;
                        /* don't stretch grid tracks */
                        align-items: start;
                        /* don't stretch items */
                        grid-auto-rows: max-content;
                }

                .msg {
                        display: flex;
                }

                .msg .bubble {
                        border: 1px solid var(--border);
                        background: #f7f7f7;
                        color: var(--fg);
                        padding: 10px 12px;
                        border-radius: 14px 14px 4px 14px;
                        font-size: 14px;
                        line-height: 1.35;
                        max-width: 72%;
                        box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
                }

                /* Bot bubble: white on gray background */
                .msg.bot .bubble {
                        background: #fff;
                        color: var(--fg);
                        border-color: var(--border);
                }

                .msg.user {
                        justify-content: flex-end;
                }

                .msg.user .bubble {
                        background: var(--primary-soft);
                        color: var(--fg);
                        border-color: var(--border);
                        border-radius: 14px 14px 14px 4px;
                }

                .chat-input {
                        display: flex;
                        gap: 8px;
                }

                #chatText {
                        flex: 1;
                        border: 1px solid rgba(0, 0, 0, .12);
                        border-radius: 14px;
                        padding: 12px 14px;
                        font: inherit;
                        outline: none;
                }

                #chatText:focus {
                        border-color: var(--primary-press);
                        box-shadow: 0 0 0 4px rgba(10, 132, 255, .12);
                }

                .typing {
                        display: inline-flex;
                        align-items: center;
                        gap: 6px;
                }

                .typing .dots {
                        display: inline-flex;
                        gap: 4px;
                }

                .typing .dots i {
                        width: 6px;
                        height: 6px;
                        border-radius: 50%;
                        background: var(--muted);
                        opacity: .35;
                        animation: dotpulse 1s ease-in-out infinite;
                }

                .typing .dots i:nth-child(2) {
                        animation-delay: .2s;
                }

                .typing .dots i:nth-child(3) {
                        animation-delay: .4s;
                }

                input,
                textarea,
                button,
                select {
                        font-family: inherit;
                        font-size: inherit;
                }

                #comments {
                        font-size: 14px;
                }

                /*==========================================================
                  VIEW TOGGLE (Summary <-> Chat)
                  - Rounded segmented control with animated blue pill.
                ==========================================================*/
                .viewtoggle {
                        position: relative;
                        display: flex;
                        align-items: center;
                        gap: 0;
                        width: 200px;
                        height: 36px;
                        padding: 4px;
                        border-radius: 999px;
                        background: var(--grey-soft);
                        border: 1px solid var(--border);
                        font-weight: 600;
                        user-select: none;
                        cursor: pointer;
                }

                .viewtoggle .label {
                        flex: 1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 13px;
                        margin: 0;
                        /* reset global .label margin */
                        padding: 0;
                        /* reset global .label padding-left */
                        text-transform: none;
                        /* stop UPPERCASE */
                        letter-spacing: 0;
                        /* reset tracking */
                        line-height: 1;
                        /* consistent vertical centering */
                        color: var(--muted);
                        position: relative;
                        z-index: 1;
                        /* sit above the pill */
                }

                /* Active segment text turns white over the blue pill */
                .card:not(.show-chat) .viewtoggle .label:first-child,
                .card.show-chat .viewtoggle .label:nth-child(2) {
                        color: #fff !important;
                }

                /* Add spacing below summary block before Comments */
                #pane-summary .summary {
                        margin-bottom: 20px;
                        /* add some space before the COMMENTS title */
                }


                .viewtoggle .pill {
                        position: absolute;
                        top: 4px;
                        left: 4px;
                        height: 28px;
                        width: calc(50% - 4px);
                        border-radius: 999px;
                        background: var(--primary);
                        box-shadow: 0 6px 18px rgba(0, 122, 255, .25);
                        transition: transform .2s;
                        z-index: 0;
                        /* behind labels */
                        pointer-events: none;
                        /* decorative only */
                }

                /* Minimal progress indicator next to "Summary" text */
                .viewtoggle .mini-dots {
                        display: none;
                        margin-left: 4px;
                        gap: 3px;
                        align-items: center;
                }

                .viewtoggle .mini-dots i {
                        width: 4px;
                        /* smaller dots */
                        height: 4px;
                        /* smaller dots */
                        border-radius: 50%;
                        background: currentColor;
                        opacity: .35;
                        animation: dotpulse 1s ease-in-out infinite;
                        /* reuse existing animation */
                }

                .viewtoggle .mini-dots i:nth-child(2) {
                        animation-delay: .2s;
                }

                .viewtoggle .mini-dots i:nth-child(3) {
                        animation-delay: .4s;
                }

                /* Show dots only while summarizing AND when Chat tab is selected */
                .card.show-chat .viewtoggle.is-summarizing .mini-dots {
                        display: inline-flex;
                }

                /* Slide the blue pill right when Chat is active */
                .card.show-chat .viewtoggle .pill {
                        transform: translateX(100%);
                }

                /* Hide Summarize button when in Chat mode */
                .card.show-chat #summarizeBtn {
                        display: none;
                }

                /* Pane visibility control (one visible at a time) */
                #pane-chat {
                        display: none;
                }

                .card.show-chat #pane-chat {
                        display: block;
                }

                .card.show-chat #pane-summary {
                        display: none;
                }

                /* Inline disclaimer shown in Chat mode (mirrors footer tone) */
                .card.show-chat::after {
                        content: "Generative AI can make mistakes. Check important info.";
                        display: block;
                        margin-top: 7px;
                        font-size: 13px;
                        color: var(--muted);
                        text-align: center;
                }

                /* Centered disclaimer inline with Comments controls */
                .disclaimer-inline {
                        position: absolute;
                        left: 0;
                        right: 0;
                        text-align: center;
                        font-size: 11px;
                        color: var(--muted);
                        pointer-events: none;
                }

                /*==========================================================
                  ACCESSIBILITY / READABILITY SCALE
                  - Slight global font-size bump via CSS variable.
                ==========================================================*/
                :root {
                        --fs: 1.08;
                }

                /* 8% larger; try 1.05–1.12 */

                body {
                        font-size: calc(16px * var(--fs));
                }

                h1 {
                        font-size: calc(28px * var(--fs));
                }

                .subtitle {
                        font-size: calc(14px * var(--fs));
                }

                .btn-primary {
                        font-size: calc(16px * var(--fs));
                }

                .btn-secondary,
                .select-model {
                        font-size: calc(14px * var(--fs));
                }

                .label,
                .caption {
                        font-size: calc(12px * var(--fs));
                }

                .summary {
                        font-size: calc(14px * var(--fs));
                }

                .summary h1 {
                        font-size: calc(24px * var(--fs));
                }

                .summary h2 {
                        font-size: calc(18px * var(--fs));
                }

                .msg .bubble {
                        font-size: calc(14px * var(--fs));
                }

                #comments,
                #chatText {
                        font-size: calc(14px * var(--fs));
                }

                .viewtoggle .label {
                        font-size: calc(14px * var(--fs));
                }
        </style>
</head>

<body>
        <div class="container">
                <div class="card" role="region" aria-labelledby="title">
                        <div class="header">
                                <div>
                                        <h1 id="title">Alert Summarizer</h1>
                                        <p class="subtitle">Generate a concise summary with one click.</p>
                                </div>
                                <div class="row">
                                        <!-- Segmented control: toggles between "Summary" and "Chat" views -->
                                        <div id="viewToggle" class="viewtoggle" role="switch" aria-checked="false">
                                                <span class="label">Summary<span class="mini-dots"
                                                                aria-hidden="true"><i></i><i></i><i></i></span></span>
                                                <span class="label">Chat</span>
                                                <span id="togglePill" class="pill" aria-hidden="true"></span>
                                        </div>
                                </div>
                        </div>
                        <!--=========================
                            SUMMARY PANE (default)
                          =========================-->
                        <div id="pane-summary">
                                <div>
                                        <div class="label">Summary</div>
                                        <!-- LLM summary output appears here; aria-live for SR updates -->
                                        <div id="summary" class="summary" role="region" aria-live="polite">Press
                                                "Summarize" to
                                                generate a concise alert summary.</div>
                                </div>

                                <div class="row" style="justify-content:flex-end;margin-top:8px">
                                        <!-- Model selector lets user choose a Responses model for summary -->
                                        <label for="modelSelect" class="sr-only">Model</label>
                                        <select id="modelSelect" class="select-model" aria-label="Model">
                                                <option value="gpt-5-nano" selected>GPT-5 nano</option>
                                                <option value="gpt-5-mini">GPT-5 mini</option>
                                                <option value="gpt-5">GPT-5</option>

                                        </select>

                                        <!-- One-click summarize action; switches to streaming/loading state -->
                                        <button id="summarizeBtn" class="btn-primary" aria-busy="false">
                                                <span class="spinner" aria-hidden="true"></span>
                                                <span class="labeltext">Summarize</span>
                                        </button>
                                </div>

                                <!-- Analyst comments area (saved locally) -->
                                <div>
                                        <div class="label">Comments</div>
                                        <textarea id="comments"
                                                placeholder="Add comments on the generated response and the alert in general…"></textarea>
                                        <div class="row" style="justify-content:space-between;margin-top:8px">
                                                <span id="charCount" class="caption">0 / 2000</span>
                                                <span class="caption disclaimer-inline">Generative AI can make mistakes.
                                                        Check important info.</span>
                                                <div class="row">
                                                        <button id="clearBtn" class="btn-secondary"
                                                                type="button">Clear</button>
                                                        <button id="saveBtn" class="btn-secondary" type="button">Save
                                                                Comment</button>
                                                </div>
                                        </div>
                                </div>
                        </div>

                        <!--=========================
                            CHAT PANE
                          =========================-->
                        <div id="pane-chat">
                                <div>
                                        <div class="label">Chat</div>
                                        <div class="chat" id="chat">
                                                <!-- Message history container (user & bot bubbles) -->
                                                <div id="chatMessages" class="chat-messages" role="region"
                                                        aria-live="polite">
                                                </div>
                                                <!-- Composer: input + send -->
                                                <div class="chat-input">
                                                        <input id="chatText" type="text"
                                                                placeholder="Ask any question about this alert…" />
                                                        <button id="chatSendBtn" class="btn-primary" type="button"
                                                                disabled>Send</button>
                                                </div>
                                        </div>
                                </div>
                        </div>

                </div>
        </div>

        <!-- Toast notification used for Save/Clear actions -->
        <div id="toast" class="toast" role="status" aria-live="polite">Saved</div>

        <script>
                // Architecture overview:
                // - Config: constants and tunables (endpoints, models, UI timings)
                // - State: runtime state shared across modules (IDs, caches, promises)
                // - UI: DOM caching + view helpers (no business logic)
                // - Utils: small pure helpers (escapeHtml, autoResize, etc.)
                // - API: network helpers (CSRF priming, OpenAI Responses call + SSE parsing)
                // - Summary: MAS prefetch (summary/chat) + summary generation/streaming
                // - Chat: prompt builder + chat send/stream UI
                // - Comments: localStorage persistence for analyst notes
                // - Init: wiring (alert ID resolution, listeners, boot)

                (function () {
                        'use strict';

                        // ==========================================================
                        // CONFIGURATION & GLOBAL STATE
                        // - MODULE_URI/CSRF_PRIMER_URL: SAS MAS endpoints for scoring & CSRF
                        // - ALERT_ID: set by URL (?alertId=) or SAS VA message
                        // - alertIdReady: Promise used to defer actions until ALERT_ID exists
                        // - OPENAI_*: OpenAI Responses endpoint + default models
                        // ==========================================================

                        // Configuration namespace
                        const Config = {
                                MODULE_URI: '/microanalyticScore/modules/aml_demo_prompt_building1_1/steps/execute',
                                CSRF_PRIMER_URL: '/microanalyticScore/modules',
                                OPENAI_URL: 'https://api.openai.com/v1/responses',
                                OPENAI_SUMMARY_MODEL: 'gpt-5-mini',
                                OPENAI_CHAT_MODEL: 'gpt-5-mini',
                                COMMENT_LIMIT: 2000,
                                ROTATE_MS: 4000,
                                // Message pool: mix of serious & lighthearted to humanize waiting
                                LOADING_MESSAGES: [
                                        // Serious
                                        "Investigating suspicious activity",
                                        "Connecting the dots between transactions",
                                        "Cross-referencing KYC data",
                                        "Scanning network relationships",
                                        "Following the money trail",
                                        "Reviewing scenario triggers",
                                        "Generating advanced insights",
                                        "Running enhanced due diligence protocols",
                                        "Finding patterns no human could see",
                                        "Hunting for needle-in-a-haystack transfers",
                                        "Checking for unusual velocity spikes",
                                        "Sifting through transaction histories",
                                        "Raising potential red flags",
                                        "Flagging politically exposed persons",
                                        "Analyzing cash structuring patterns",
                                        "Verifying source of funds",
                                        // Fun
                                        "Searching mattress stores (politely)",
                                        "Following the breadcrumbs",
                                        "Checking today's horoscope",
                                        "With great power comes great compliance responsibility – Uncle Ben",
                                        "I'm gonna make him an offer he can't explain to compliance – The Godfather",
                                        "May the fraud be with you – Star Wars",
                                        "Looking for the usual suspects",
                                        "Elementary, my dear Watson... the account is offshore – Sherlock Holmes",
                                        "The name's Bond... Transaction Bond – James Bond",
                                        "Houston, we have a suspicious transfer – Apollo 13",
                                        "Winter is coming... for fraudsters – Game of Thrones",
                                        "Binge-watching transaction histories",
                                        "Taking a siesta"
                                ]
                        };

                        // State management namespace
                        const State = {
                                ALERT_ID: null,               // will be filled by VA
                                ALERT_ID_SOURCE: 'unset',     // track the source for diagnostics
                                resolveAlertIdReady: null,
                                alertIdReady: null,
                                chatHistory: [],              // Rolling window of the most recent exchanges to preserve context
                                summaryCache: null,
                                chatCache: null,
                                summaryMasPromise: null,
                                chatMasPromise: null,
                                chatBusy: false,              // true while a request is in flight
                                csrfToken: null

                        };

                        // Initialize the promise
                        State.alertIdReady = new Promise(r => (State.resolveAlertIdReady = r));

                        // UI namespace - cache DOM elements
                        const UI = {
                                elements: {},

                                init() {
                                        // ===== UI ELEMENT REFERENCES =====
                                        this.elements = {
                                                summarizeBtn: document.getElementById('summarizeBtn'),
                                                summaryEl: document.getElementById('summary'),
                                                commentsEl: document.getElementById('comments'),
                                                charCountEl: document.getElementById('charCount'),
                                                saveBtn: document.getElementById('saveBtn'),
                                                clearBtn: document.getElementById('clearBtn'),
                                                toast: document.getElementById('toast'),
                                                modelSelect: document.getElementById('modelSelect'),
                                                chatMessages: document.getElementById('chatMessages'),
                                                chatText: document.getElementById('chatText'),
                                                chatSendBtn: document.getElementById('chatSendBtn'),
                                                cardEl: document.querySelector('.card'),
                                                titleEl: document.getElementById('title'),
                                                subtitleEl: document.querySelector('.subtitle'),
                                                toggleEl: document.getElementById('viewToggle')
                                        };

                                        // Disable summarize until an ALERT_ID exists (prevents premature calls).
                                        this.elements.summarizeBtn.disabled = true;
                                },

                                // ==========================================================
                                // TOAST & LOADING RENDER HELPERS
                                // ==========================================================
                                showToast(msg) {
                                        this.elements.toast.textContent = msg;
                                        this.elements.toast.classList.add('show');
                                        setTimeout(() => this.elements.toast.classList.remove('show'), 1400);
                                },

                                renderWorking(message) {
                                        // Shows a status line + shimmering skeleton to indicate progress
                                        this.elements.summaryEl.innerHTML = `<div class="working">${message}<span class="dots"><i></i><i></i><i></i></span></div>
      <div class="skel"><div class="line" style="width:88%"></div><div class="line" style="width:96%"></div><div class="line" style="width:72%"></div></div>`;
                                },

                                // ==========================================================
                                // VIEW TOGGLE BEHAVIOR
                                // - setView(true)  -> Chat mode
                                // - setView(false) -> Summary mode
                                // - Updates ARIA and titles/subtitles accordingly
                                // ==========================================================
                                setView(showChat) {
                                        this.elements.cardEl.classList.toggle('show-chat', showChat);
                                        this.elements.titleEl.textContent = showChat ? 'Alert Chat' : 'Alert Summarizer';
                                        this.elements.subtitleEl.textContent = showChat
                                                ? 'Converse with our chatbot for alert insights.'
                                                : 'Generate a concise summary with one click.';
                                        this.elements.toggleEl.setAttribute('aria-checked', showChat ? 'true' : 'false');
                                }
                        };

                        // Utility functions namespace
                        const Utils = {
                                // next animation frame helper (await to ensure UI paints)
                                nextFrame: () => new Promise(requestAnimationFrame),

                                // Escape user-provided text for safe HTML insertion
                                escapeHtml(s) {
                                        return s.replace(/[&<>"']/g, m => ({
                                                "&": "&amp;",
                                                "<": "&lt;",
                                                ">": "&gt;",
                                                "\"": "&quot;",
                                                "'": "&#39;"
                                        }[m]));
                                },

                                outputsToMap(outputs) {
                                        const m = {};
                                        (outputs || []).forEach(o => m[o.name] = o.value);
                                        return m;
                                },

                                trimChars(s, max = 8000) {
                                        if (!s) return '';
                                        return s.length <= max ? s : (s.slice(0, max) + '\n[...trimmed]');
                                },

                                // Auto-expand the comment box
                                autoResize(el) {
                                        el.style.height = 'auto';
                                        el.style.height = el.scrollHeight + 'px';
                                }
                        };

                        // API namespace
                        const API = {
                                // ==========================================================
                                // NETWORK/FORMAT HELPERS
                                // - getCsrfToken: prime CSRF token by hitting MAS index
                                // - extractOpenAIText: normalize Responses API shapes into text
                                // ==========================================================
                                async getCsrfToken() {
                                        if (State.csrfToken !== null) return State.csrfToken; // cached ('' if none)
                                        const res = await fetch(Config.CSRF_PRIMER_URL, { method: 'GET', credentials: 'include' });
                                        State.csrfToken =
                                                res.headers.get('X-CSRF-TOKEN') ||
                                                res.headers.get('x-csrf-token') ||
                                                '';
                                        return State.csrfToken;
                                },

                                extractOpenAIText(j) {
                                        // Responses API can return:
                                        // - output_text (string)
                                        // - output: [{content:[{type:'output_text', text:'...'}]}]
                                        // - chat-style: choices[0].message.content
                                        if (j && typeof j.output_text === 'string' && j.output_text.trim()) return j.output_text;
                                        if (Array.isArray(j?.output)) {
                                                for (const item of j.output) {
                                                        const content = item?.content;
                                                        if (Array.isArray(content)) {
                                                                for (const c of content) {
                                                                        if (typeof c?.text === 'string' && c.text.trim()) return c.text;
                                                                        if (c?.type === 'output_text' && c?.text) return c.text;
                                                                }
                                                        }
                                                }
                                        }
                                        if (j?.choices?.[0]?.message?.content) return j.choices[0].message.content;
                                        return null;
                                },

                                async callOpenAI(systemPrompt, apiKey, chosen_model = Config.OPENAI_CHAT_MODEL, onDelta /* optional */) {
                                        const body = {
                                                model: chosen_model,
                                                input: systemPrompt,
                                                reasoning: { effort: "medium" },
                                                text: { verbosity: "low" },
                                                stream: !!onDelta
                                        };

                                        const res = await fetch(Config.OPENAI_URL, {
                                                method: 'POST',
                                                headers: {
                                                        'Authorization': `Bearer ${apiKey}`,
                                                        'Content-Type': 'application/json',
                                                        'Accept': onDelta ? 'text/event-stream' : 'application/json'
                                                },
                                                body: JSON.stringify(body)
                                        });

                                        // Non-streaming: expect JSON with output_text/choices
                                        if (!onDelta) {
                                                const json = await res.json().catch(() => ({}));
                                                if (!res.ok) throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                                                const txt = API.extractOpenAIText(json);
                                                if (!txt) throw new Error('LLM returned no text payload');
                                                return txt;
                                        }

                                        // --- Streaming path (SSE) ---
                                        if (!res.ok || !res.body) {
                                                const text = await res.text().catch(() => '');
                                                throw new Error(`${res.status} ${res.statusText}\n${text.slice(0, 500)}`);
                                        }

                                        const reader = res.body.getReader();
                                        const decoder = new TextDecoder();
                                        let carry = '';
                                        let full = '';

                                        while (true) {
                                                const { value, done } = await reader.read();
                                                if (done) break;
                                                carry += decoder.decode(value, { stream: true });

                                                // Split Server-Sent-Event frames
                                                const frames = carry.split('\n\n');
                                                carry = frames.pop() || '';

                                                for (const frame of frames) {
                                                        // concatenate all data: lines in the frame
                                                        const dataLines = frame
                                                                .split('\n')
                                                                .filter(l => l.startsWith('data:'))
                                                                .map(l => l.slice(5).trim())
                                                                .join('\n');

                                                        if (!dataLines || dataLines === '[DONE]') continue;

                                                        let evt;
                                                        try { evt = JSON.parse(dataLines); } catch { continue; }

                                                        if (evt.type === 'response.output_text.delta') {
                                                                const delta = evt.delta || '';
                                                                if (delta) {
                                                                        full += delta;
                                                                        try { onDelta(delta, full, evt); } catch { /* avoid breaking stream */ }
                                                                }
                                                        } else if (evt.type === 'error') {
                                                                throw new Error(evt.error?.message || 'Streaming error');
                                                        }
                                                        // Other event types (created/completed) are ignored for now
                                                }
                                        }
                                        return full.trim();
                                }
                        };

                        // Summary namespace
                        const Summary = {
                                // ==========================================================
                                // MAS PREFETCH
                                // - Pre-call SAS MAS to build prompts/keys for Summary and Chat.
                                // - Results cached in summaryCache/chatCache; promises guard duplicate calls.
                                // ==========================================================

                                // Prefetch summary-specific prompt/key/cutoff from MAS
                                async prefetchSummary() {
                                        await State.alertIdReady;
                                        const csrf = await API.getCsrfToken();
                                        const payload = {
                                                inputs: [
                                                        { name: "ALERT_ID_", value: State.ALERT_ID },
                                                        { name: "SUMMARY_OR_CHAT_", value: "summary" }
                                                ]
                                        };
                                        const res = await fetch(Config.MODULE_URI, {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json', 'X-CSRF-TOKEN': csrf },
                                                credentials: 'include',
                                                body: JSON.stringify(payload)
                                        });

                                        // MAS returns an outputs array [{name, value}, ...]; normalize to map
                                        const json = await res.json().catch(() => ({}));

                                        if (!res.ok) {
                                                // surface server error payload if present
                                                throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                                        }

                                        const out = Utils.outputsToMap(json.outputs || []);
                                        State.summaryCache = {
                                                systemPrompt: out['systemPrompt'],
                                                key: out['key'],
                                                cutoff: out['CUTOFF_DATE']
                                        };

                                        return State.summaryCache;
                                },

                                // Prefetch chat-specific data string + key from MAS
                                async prefetchChat() {
                                        await State.alertIdReady;
                                        const csrf = await API.getCsrfToken();
                                        const payload = {
                                                inputs: [
                                                        { name: "ALERT_ID_", value: State.ALERT_ID },
                                                        { name: "SUMMARY_OR_CHAT_", value: "chat" }
                                                ]
                                        };
                                        const res = await fetch(Config.MODULE_URI, {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json', 'X-CSRF-TOKEN': csrf },
                                                credentials: 'include',
                                                body: JSON.stringify(payload)
                                        });
                                        const json = await res.json().catch(() => ({}));

                                        if (!res.ok) {
                                                throw new Error(`${res.status} ${res.statusText}\n${JSON.stringify(json).slice(0, 500)}`);
                                        }

                                        const out = Utils.outputsToMap(json.outputs || []);
                                        State.chatCache = {
                                                dataString: out['systemPrompt'] || '',
                                                key: out['key']
                                        };

                                        return State.chatCache;
                                },

                                // Kick off MAS/OpenAI prefetch in an idempotent way.
                                // - Prefetches Summary first (prompt/key/cutoff), then Chat (data string/key).
                                // - Caches the in-flight Promises so repeated calls don't duplicate network work.
                                // - Safe to call as soon as ALERT_ID is set; internals await alertIdReady.
                                startPrefetch() {
                                        if (!State.summaryMasPromise)
                                                State.summaryMasPromise = this.prefetchSummary().catch(e => {
                                                        console.error('[prefetch summary]', e);
                                                        State.summaryMasPromise = null;
                                                        throw e;
                                                });
                                        if (!State.chatMasPromise)
                                                State.chatMasPromise = (State.summaryMasPromise || this.prefetchSummary())
                                                        .then(() => this.prefetchChat())
                                                        .catch(e => {
                                                                console.error('[prefetch chat]', e);
                                                                State.chatMasPromise = null;
                                                                throw e;
                                                        });
                                },

                                // ==========================================================
                                // SUMMARY ACTION
                                // - Waits for ALERT_ID
                                // - Shows rotating status messages
                                // - Streams Responses text into #summary
                                // - Appends cutoff note if provided by MAS
                                // ==========================================================
                                async summarize() {
                                        // Wait until VA supplies the alert id (or URL fallback)
                                        if (!State.ALERT_ID) {
                                                UI.renderWorking('Waiting for Alert ID from Visual Analytics');
                                                await State.alertIdReady;
                                        }
                                        console.log(`[id] summarize() with ALERT_ID=${State.ALERT_ID} (source=${State.ALERT_ID_SOURCE})`);

                                        UI.elements.summarizeBtn.disabled = true;
                                        UI.elements.summarizeBtn.classList.add('loading');
                                        UI.elements.summarizeBtn.setAttribute('aria-busy', 'true');

                                        let started = false;

                                        // Shuffle once and rotate on interval
                                        const shuffledMessages = [...Config.LOADING_MESSAGES].sort(() => Math.random() - 0.5);
                                        let msgIndex = 0;

                                        UI.renderWorking(shuffledMessages[msgIndex]);
                                        await Utils.nextFrame();

                                        const timer = setInterval(() => {
                                                if (started) return;
                                                msgIndex = (msgIndex + 1) % shuffledMessages.length;
                                                UI.renderWorking(shuffledMessages[msgIndex]);
                                        }, Config.ROTATE_MS);

                                        // Mark the toggle as "busy" to show mini-dots when on Chat view
                                        UI.elements.toggleEl.classList.add('is-summarizing');
                                        UI.elements.toggleEl.setAttribute('aria-busy', 'true');

                                        let rafId = null;

                                        try {
                                                // Call OpenAI with MAS-provided key
                                                const chosenModel = UI.elements.modelSelect.value || Config.OPENAI_SUMMARY_MODEL;
                                                const s = State.summaryCache || await (State.summaryMasPromise || (this.startPrefetch(), State.summaryMasPromise));
                                                if (!s?.systemPrompt) throw new Error('Summary data not ready from MAS');
                                                if (!s?.key) throw new Error('OpenAI API key missing from MAS');
                                                let buffer = '';
                                                const flush = () => {
                                                        if (UI.elements.summaryEl.innerHTML !== buffer) {
                                                                UI.elements.summaryEl.innerHTML = buffer;
                                                        }  // one DOM write per frame --> smoother UI 
                                                        rafId = null;
                                                };

                                                let finalText = await API.callOpenAI(
                                                        s.systemPrompt,
                                                        s.key,
                                                        chosenModel,
                                                        (_delta, full) => {
                                                                if (!started) {
                                                                        started = true;
                                                                        clearInterval(timer);         // stop the skeleton/rotator immediately
                                                                }
                                                                buffer = full;
                                                                if (!rafId) rafId = requestAnimationFrame(flush);
                                                        }
                                                );

                                                // Final synchronous write (includes cutoff if present)
                                                buffer = s.cutoff
                                                        ? finalText + `<div class="cutoff">${s.cutoff}</div>`
                                                        : finalText;

                                                // Ensure anything pending is canceled, then do one last write
                                                if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
                                                UI.elements.summaryEl.innerHTML = buffer;

                                        } catch (e) {
                                                UI.elements.summaryEl.textContent = `Error:\n${e.message}`;
                                                console.error(e);
                                        } finally {
                                                clearInterval(timer);
                                                UI.elements.summarizeBtn.disabled = false;
                                                UI.elements.summarizeBtn.classList.remove('loading');
                                                UI.elements.summarizeBtn.setAttribute('aria-busy', 'false');
                                                UI.elements.toggleEl.classList.remove('is-summarizing');
                                                UI.elements.toggleEl.removeAttribute('aria-busy');
                                                if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
                                        }
                                }
                        };

                        // Chat namespace
                        const Chat = {
                                // ==========================================================
                                // CHAT PROMPT BUILDER
                                // - Assembles a single string prompt with SYSTEM + HISTORY + DATA + USER
                                // - Restricts customer-specific claims to MAS-provided Data section
                                // ==========================================================
                                // Build the chat system prompt locally using MAS "chat" data string + user message.
                                buildChatPrompt(dataString, userMessage, history = []) {
                                        const system = [
                                                'You are a concise, friendly AML assistant embedded in the SAS AML solution.',
                                                'Customer/alert-specific facts MUST come only from the Data section.',
                                                'If a requested detail is missing in Data, be very clear that it is missing. Do not invent values.',
                                                'You MAY add general AML knowledge (regulations, definitions, typologies).',
                                                'Write in clear, friendly, natural prose — no bullet points. Keep it brief.',
                                                'Start by directly answering the question',
                                                'Only answer questions related to AML',
                                                'Avoid exposing or inferring PII beyond what appears in Data.',
                                                `Alert ID: ${State.ALERT_ID || 'unknown'}`
                                        ].join(' ');

                                        // Use up to the last 3 exchanges (i.e., 6 messages), excluding the current user message if already added.
                                        let hist = Array.isArray(history) ? history.slice() : [];
                                        if (hist.length && hist[hist.length - 1].role === 'user') hist.pop(); // drop current turn if already pushed
                                        const recent = hist.slice(-6);
                                        const historyBlock = recent.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n');

                                        return [
                                                `SYSTEM:\n${system}`,
                                                historyBlock ? `HISTORY (last ${Math.floor(recent.length / 2)} exchanges):\n${Utils.trimChars(historyBlock, 2000)}` : null,
                                                `DATA:\n${Utils.trimChars(dataString, 7000)}`,
                                                `USER:\n${userMessage}`,
                                                'ASSISTANT:'
                                        ].filter(Boolean).join('\n\n');
                                },

                                // ==========================================================
                                // OPENAI CALLERS (chat + shared streaming)
                                // - chatQuery: resolves MAS chat data, builds prompt, calls Responses
                                // ==========================================================
                                async chatQuery(userText, onDelta) {
                                        // Ensure we have an ALERT_ID (VA or URL)
                                        if (!State.ALERT_ID) {
                                                this.addMessage('bot', '<em>Waiting for Alert ID from Visual Analytics…</em>');
                                                await State.alertIdReady;
                                        }

                                        const cc = State.chatCache || await (State.chatMasPromise || (Summary.startPrefetch(), State.chatMasPromise));
                                        const apiKey = cc.key || State.summaryCache?.key;
                                        if (!apiKey) throw new Error('OpenAI API key not found in MAS output');

                                        const prompt = this.buildChatPrompt(cc.dataString, userText, State.chatHistory);
                                        const reply = await API.callOpenAI(prompt, apiKey, Config.OPENAI_CHAT_MODEL, onDelta);
                                        return reply.trim();
                                },

                                // ==========================================================
                                // CHAT FRONTEND: MESSAGE FLOW & INPUT HANDLING
                                // - addMessage: renders a bubble (user/bot)
                                // - showBotThinking: temporary "typing" bubble
                                // - handleSend: orchestrates send -> stream -> finalize
                                // ==========================================================

                                // Enable/disable Send based on input emptiness and busy state
                                refreshSend() {
                                        const empty = UI.elements.chatText.value.trim().length === 0;
                                        UI.elements.chatSendBtn.disabled = State.chatBusy || empty; // reuse .btn-primary:disabled styling
                                },

                                // Render a new message bubble (html content is trusted/escaped by caller)
                                addMessage(role, html) {
                                        const wrap = document.createElement('div');
                                        wrap.className = 'msg ' + role;
                                        const bubble = document.createElement('div');
                                        bubble.className = 'bubble';
                                        bubble.innerHTML = html;
                                        wrap.appendChild(bubble);
                                        UI.elements.chatMessages.appendChild(wrap);
                                        UI.elements.chatMessages.scrollTop = UI.elements.chatMessages.scrollHeight;
                                },

                                // Show a temporary "Thinking..." bubble with animated dots
                                showBotThinking() {
                                        const wrap = document.createElement('div');
                                        wrap.className = 'msg bot';
                                        const bubble = document.createElement('div');
                                        bubble.className = 'bubble';
                                        bubble.innerHTML = `<span class="typing">Thinking<span class="dots"><i></i><i></i><i></i></span></span>`;
                                        wrap.appendChild(bubble);
                                        UI.elements.chatMessages.appendChild(wrap);
                                        UI.elements.chatMessages.scrollTop = UI.elements.chatMessages.scrollHeight;
                                        return { bubble, stop: () => { wrap.remove(); } };
                                },

                                // Send handler: push user msg, stream bot reply, maintain chatHistory window
                                async handleSend() {
                                        const text = UI.elements.chatText.value.trim();
                                        if (!text) return;

                                        this.addMessage('user', Utils.escapeHtml(text));
                                        State.chatHistory.push({ role: 'user', content: text });
                                        UI.elements.chatText.value = '';
                                        State.chatBusy = true;
                                        this.refreshSend();

                                        const thinking = this.showBotThinking();
                                        await Utils.nextFrame(); // ensure typing anim paints

                                        let stopped = false;
                                        let chatRaf = null;
                                        let chatBuf = '';
                                        const messagesEl = UI.elements.chatMessages;            //  cache refs
                                        const bubbleEl = thinking.bubble;

                                        try {
                                                const chatFlush = () => {
                                                        if (bubbleEl.innerHTML !== chatBuf) {
                                                                bubbleEl.innerHTML = chatBuf;
                                                        }
                                                        messagesEl.scrollTop = messagesEl.scrollHeight;
                                                        chatRaf = null;
                                                        stopped = true;
                                                };

                                                const final = await this.chatQuery(text, (_delta, full) => {
                                                        chatBuf = Utils.escapeHtml(full).replace(/\n/g, '<br>');
                                                        if (!chatRaf) chatRaf = requestAnimationFrame(chatFlush);
                                                });

                                                // 🔧 guarantee last frame: cancel pending RAF and write final HTML once
                                                if (chatRaf) { cancelAnimationFrame(chatRaf); chatRaf = null; }
                                                const finalHtml = Utils.escapeHtml(final).replace(/\n/g, '<br>');
                                                if (bubbleEl.innerHTML !== finalHtml) {
                                                        bubbleEl.innerHTML = finalHtml;
                                                        messagesEl.scrollTop = messagesEl.scrollHeight;
                                                }
                                                stopped = true;

                                                State.chatHistory.push({ role: 'assistant', content: final });
                                                // Keep only the latest 3 exchanges (6 messages)
                                                if (State.chatHistory.length > 6) {
                                                        State.chatHistory.splice(0, State.chatHistory.length - 6);
                                                }
                                        } catch (e) {
                                                bubbleEl.innerHTML = `<em>Sorry, I couldn't complete that: ${Utils.escapeHtml(e.message)}</em>`;
                                                console.error('[chat] error:', e);
                                                // Roll back last user entry if request failed early
                                                if (State.chatHistory.length && State.chatHistory[State.chatHistory.length - 1].role === 'user') {
                                                        State.chatHistory.pop();
                                                }
                                        } finally {
                                                // If no delta ever arrived (error before stream), remove the typing bubble
                                                if (!stopped && thinking.stop) thinking.stop();
                                                State.chatBusy = false;
                                                this.refreshSend();
                                                UI.elements.chatText.focus();
                                                if (chatRaf) { cancelAnimationFrame(chatRaf); chatRaf = null; }
                                        }
                                }

                        };

                        // Comments namespace
                        const Comments = {
                                // ==========================================================
                                // COMMENTS: LOCAL STORAGE PERSISTENCE
                                // - saveComment stores a timestamped entry under a fixed key
                                // - clearComment resets the field and counter
                                // ==========================================================
                                saveComment() {
                                        const key = 'aml-summary-comments';
                                        const existing = JSON.parse(localStorage.getItem(key) || '[]');
                                        const entry = {
                                                ts: new Date().toISOString(),
                                                alertId: State.ALERT_ID,
                                                comment: UI.elements.commentsEl.value.trim(),
                                                summary: UI.elements.summaryEl.textContent.trim()
                                        };
                                        if (!entry.comment) {
                                                UI.showToast('Nothing to save');
                                                return;
                                        }
                                        existing.push(entry);
                                        localStorage.setItem(key, JSON.stringify(existing));
                                        UI.showToast('Comment saved locally');
                                },

                                clearComment() {
                                        UI.elements.commentsEl.value = '';
                                        UI.elements.commentsEl.dispatchEvent(new Event('input'));
                                        UI.showToast('Cleared');
                                }
                        };

                        // Initialization namespace
                        const Init = {
                                // ==========================================================
                                // ALERT ID RESOLUTION (URL first, then VA message bus)
                                // - URL ?alertId=... is used initially; if VA later provides a parameter value, it will replace the URL one.
                                // NOTE: Assumes `va.messagingUtil` is available (running inside SAS VA).
                                // ==========================================================
                                checkAlertId() {
                                        console.log('[id] init: waiting for alert id (from VA or URL)');

                                        // 1) If an alertId is provided via URL use it
                                        const urlAlertId = new URLSearchParams(location.search).get('alertId');
                                        if (urlAlertId) {
                                                State.ALERT_ID = urlAlertId;
                                                State.ALERT_ID_SOURCE = 'url';
                                                console.log('[id] Using URL parameter ?alertId=', State.ALERT_ID);
                                                State.resolveAlertIdReady?.(State.ALERT_ID);
                                                UI.elements.summarizeBtn.disabled = false;
                                                Summary.startPrefetch();
                                                console.log('[id] summarizeBtn enabled (source=url)');
                                        }

                                        // 2) Primary path: get alert id from VA (parameter preferred, else data cell)
                                        va.messagingUtil.setOnDataReceivedCallback(function (vaMsgObj) {
                                                console.log('[id] VA message received:', vaMsgObj);

                                                // Prefer first parameter value if available
                                                const paramVal = vaMsgObj?.parameters?.[0]?.value;

                                                console.log('[id] candidates -> paramVal:', paramVal);

                                                if (paramVal != null) {  // Only override if VA actually has a value
                                                        State.ALERT_ID = String(paramVal);

                                                        State.ALERT_ID_SOURCE = 'va-parameter';
                                                        console.log(`[id] Using ${State.ALERT_ID_SOURCE}: ${State.ALERT_ID}`);
                                                        State.resolveAlertIdReady?.(State.ALERT_ID);          // resolve the waiters (first time)
                                                        UI.elements.summarizeBtn.disabled = false;            // enable the button now that we have it
                                                        Summary.startPrefetch();
                                                        console.log(`[id] summarizeBtn enabled (source=${State.ALERT_ID_SOURCE})`);
                                                }
                                        });
                                },

                                setupComments() {
                                        // ==========================================================
                                        // COMMENTS UX
                                        // - Auto-resize textarea
                                        // - Enforce character limit
                                        // ==========================================================

                                        UI.elements.commentsEl.addEventListener('input', () => Utils.autoResize(UI.elements.commentsEl));
                                        window.addEventListener('load', () => Utils.autoResize(UI.elements.commentsEl));
                                        UI.elements.commentsEl.addEventListener('input', () => {
                                                if (UI.elements.commentsEl.value.length > Config.COMMENT_LIMIT) {
                                                        UI.elements.commentsEl.value = UI.elements.commentsEl.value.slice(0, Config.COMMENT_LIMIT);
                                                }
                                                UI.elements.charCountEl.textContent = `${UI.elements.commentsEl.value.length} / ${Config.COMMENT_LIMIT}`;
                                        });
                                        // Initialize count on load
                                        UI.elements.commentsEl.dispatchEvent(new Event('input'));
                                },

                                bindEvents() {
                                        // Wire up Summary actions
                                        UI.elements.summarizeBtn.addEventListener('click', () => Summary.summarize());
                                        UI.elements.saveBtn.addEventListener('click', () => Comments.saveComment());    // Saves to localStorage only (per-browser, per-user). No server persistence.
                                        UI.elements.clearBtn.addEventListener('click', () => Comments.clearComment());

                                        // initialize + update on typing
                                        Chat.refreshSend();
                                        UI.elements.chatText.addEventListener('input', () => Chat.refreshSend());

                                        // Keyboard + click bindings for chat send
                                        UI.elements.chatSendBtn.addEventListener('click', () => Chat.handleSend());
                                        UI.elements.chatText.addEventListener('keydown', (e) => {
                                                if (e.key === 'Enter' && !e.shiftKey) {
                                                        e.preventDefault();
                                                        Chat.handleSend();
                                                }
                                        });

                                        // click anywhere on the toggle to switch
                                        UI.elements.toggleEl.addEventListener('click', () => UI.setView(!UI.elements.cardEl.classList.contains('show-chat')));
                                },

                                init() {
                                        UI.init();
                                        this.checkAlertId();
                                        this.setupComments();
                                        this.bindEvents();

                                        // Seed with a welcome message (helps discoverability)
                                        Chat.addMessage('bot',
                                                "Hi! I am a friendly chatbot that will use the alert data and my general AML knowledge to help you. What's on your mind?");

                                        // default to Summary view
                                        UI.setView(false);
                                }
                        };

                        // Initialize the application
                        Init.init();

                })();
        </script>
</body>

</html>

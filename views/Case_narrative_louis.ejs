<!DOCTYPE html>
<html lang="en">

<head>
    <script src='./javascripts/sas/util/messagingUtil.js'></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 16px;
            margin: 0 30px;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        pre {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
        }

        details {
            margin: 20px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 90%;
            padding: 10px;
        }

        summary {
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
            color: #fff;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 20px;
            /* inset */
            border-radius: 5px;
            box-shadow: inset 0px 0px 0px 1px #0a0a0a;
        }

        form {
            display: flex;
            flex-direction: column;
            margin: 10px;
            align-items: center;
            justify-content: center;
        }

        label {
            margin-bottom: 10px;
        }

        textarea {
            width: 90%;
            min-height: 80px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            text-wrap: wrap;
            height: auto;
            overflow: hidden;
            resize: none;
            padding: 0.8em;
        }

        #chatgptResponse {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #02022f;
        }

        .loading {
            display: none;
            z-index: 999;
            height: 2em;
            width: 2em;
        }

        .api-response-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px;
        }

        .api-pricing {
            display: flex;
            width: 80%;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
        }

        .api-pricing>p {
            margin-left: 10px;
        }
    </style>
    <title>Data Workbench</title>
</head>

<body>
    <details>
        <summary>API Response</summary>
        <h2>API response</h2>
        <pre id="apiResponse"></pre>
        <h2>Filtered Scenario Fired Events</h2>
        <pre id="scenario_fired_event"></pre>
        <h2>Filtered Transactions</h2>
        <pre id="transactions"></pre>
        <h2>Personal Information</h2>
        <pre id="Party_info"></pre>
        <h2>Nonnormalized graph</h2>
        <pre id="postResponse"></pre>
    </details>
    <details>
        <summary>Graph Of Transactions</summary>
        <h2>Vertices JSON</h2>
        <pre id="verticesJson"></pre>
        <h2>Edges JSON</h2>
        <pre id="edgesJson"></pre>
        <p id="alertid"></p>
    </details>

    <form id="chatForm">
        <div class="row">
            <label for="model">Model:</label>
            <select id="model" name="model">
                <option value="gpt-4o">GPT-4o</option>
                <option value="gpt-4o-mini">GPT-4o mini</option>
            </select>
        </div>
        <button type="submit" class="btn-primary" id="callApiButton">Case Narrative
        </button>
    </form>

    <h2 class="loading" id="loading-indicator">
        Loading response
    </h2>

    <div class="api-response-box">
        <pre style="width: 100%;"><span id="chatgptResponse"></span></pre>
    </div>
    <p hidden><span id="apiKeyContainer"></span></p>
    <p hidden><span id="alertid"></span></p>

    <script>
        "use strict";

        function autoGrow(element) {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        }

        // Attach the autoGrow function to input event for all textareas
        document.querySelectorAll('textarea').forEach(textarea => {
            textarea.addEventListener('input', function () {
                autoGrow(this);
            });
            // Call autoGrow on page load to set initial height
            autoGrow(textarea);
        });

        const myHeaders = new Headers();
        myHeaders.append("Cookie", "sas-ingress-nginx=6866adc2289a112d6ea7fd0775261540|f0e9e5d83f1b459459b54939af4feb2b");

        const requestOptions = {
            method: "GET",
            headers: myHeaders,
            redirect: "follow"
        };

        va.messagingUtil.setOnDataReceivedCallback(updateURL);

        function updateURL(vaMsgObj) {
            console.log('Received vaMsgObj:', vaMsgObj);
            if (vaMsgObj && vaMsgObj.data && vaMsgObj.data.length > 0) {
                const apiKey = vaMsgObj.data[0][0];
                console.log('[debug]: Fetched API Key:', apiKey);
                document.getElementById("apiKeyContainer").textContent = apiKey;

                // Extract the value from the parameters array
                if (vaMsgObj.parameters && vaMsgObj.parameters.length > 0) {
                    const alert_id = vaMsgObj.parameters[0].value;
                    console.log('[debug]: Fetched Parameter Value:', alert_id);
                    document.getElementById("alertid").textContent = alert_id;
                } else {
                    document.getElementById("alertid").textContent = "No parameter value available";
                }
            } else {
                document.getElementById("apiKeyContainer").textContent = "No API key available";
                document.getElementById("alertid").textContent = "No parameter value available";
            }
        }

        async function getCsrfToken() {
            const url = 'https://amlglobalteam-03.unx.sas.com/svi-sand/traversals?calculateMetrics=false&expansionLimit=2000';
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include'
                });
                const csrfToken = response.headers.get('X-CSRF-TOKEN');
                if (!csrfToken) {
                    console.error('CSRF token not found in response headers');
                    throw new Error('CSRF token not found in response headers');
                }
                console.log("[debug]: csrfToken set")
                return csrfToken;
            } catch (error) {
                console.error('[debug]: Error in getCsrfToken:', error);
                throw error;
            }
        }

        async function postData(csrfToken) {
            const url = 'https://amlglobalteam-03.unx.sas.com/svi-sand/traversals?calculateMetrics=false&expansionLimit=2000';
            const data = {
                "edgeTypes": [
                    "social_link"
                ],
                "depth": 2,
                "extendedFormat": true,
                "graphObjectIds": [
                    {
                        "type": "PTY",
                        "id": "326315"
                    },
                    {
                        "type": "alerts",
                        "id": "3d9a7119-640a-420a-a273-e7f0520259f4"
                    }
                ],
                "query": {
                    "type": "object",
                    "objectIds": [
                        {
                            "type": "PTY",
                            "id": "326315"
                        }
                    ]
                }
            };

            const myHeaderspost = new Headers();
            myHeaderspost.append("Content-Type", "application/json");
            myHeaderspost.append("Cookie", "sas-ingress-nginx=465a78167134495424fe1d90f9dbaa56|12b794cb5ca279bec1edb7e510234855");
            myHeaderspost.append("X-CSRF-TOKEN", csrfToken);

            const requestOptionspost = {
                method: "POST",
                headers: myHeaderspost,
                body: JSON.stringify(data),
                redirect: "follow"
            };

            try {
                const response = await fetch(url, requestOptionspost);
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                const postResponseText = await response.json();
                document.getElementById('postResponse').textContent = JSON.stringify(postResponseText, null, 2);

                const vertices = postResponseText.vertices.map(vertex => ({
                    type: vertex.type,
                    id: vertex.id,
                    typeLabel: vertex.typeLabel,
                    label: vertex.label
                }));

                const edges = postResponseText.edges.map(edge => ({
                    id: edge.id,
                    endpoints: edge.endpoints.map(endpoint => ({
                        type: endpoint.type,
                        id: endpoint.id
                    })),
                    subtype: edge.subtype,
                    label: edge.label
                }));

                console.log("[debug]: set pty and graph data");

                document.getElementById('verticesJson').textContent = JSON.stringify(vertices, null, 2);
                document.getElementById('edgesJson').textContent = JSON.stringify(edges, null, 2);
            } catch (error) {
                console.error('[debug]: Error in postData:', error);
                document.getElementById('postResponse').textContent = `Error: ${error}`;
            }
        }

        async function fetchData() {
            const alertIdElement = document.getElementById("alertid");
            let alertId = alertIdElement.textContent.trim(); // Get the alert ID from the element

            if (!alertId) {
                console.warn('[debug]: Alert ID is not immediately available. Waiting for it to be populated...');

                // Wait for the alert ID to be available
                for (let i = 0; i < 10; i++) {  // Retry up to 10 times (adjust as needed)
                    await new Promise(resolve => setTimeout(resolve, 500));  // Wait for 500ms
                    alertId = alertIdElement.textContent.trim();
                    if (alertId) {
                        break;  // Exit the loop once alertId is available
                    }
                }
            }

            if (!alertId) {
                console.error('Alert ID is still not available after waiting.');
                return;
            }
            const alertUrl = `https://amlglobalteam-03.unx.sas.com/svi-alert/alerts/${alertId}`;

            console.log("[debug]: called alerts data");
            try {
                const response = await fetch(alertUrl, requestOptions);
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                const data = await response.json();
                const currentAlertingEventId = data.currentAlertingEventId;
                const actionableEntityId = data.actionableEntityId;
                document.getElementById("apiResponse").innerHTML = JSON.stringify(data, null, 2);

                const alertingEventsUrl = `https://amlglobalteam-03.unx.sas.com/svi-alert/alertingEvents/${currentAlertingEventId}`;
                const alertingEventsResponse = await fetch(alertingEventsUrl, requestOptions);
                if (!alertingEventsResponse.ok) {
                    throw new Error('Network response was not ok ' + alertingEventsResponse.statusText);
                }
                const alertingEventsData = await alertingEventsResponse.json();
                const filteredScenarioFiredEvents = alertingEventsData.scenarioFiredEvents.map(event => ({
                    scenarioName: event.scenarioName,
                    scenarioDescription: event.scenarioDescription,
                    messageTemplateText: event.messageTemplateText
                }));
                document.getElementById("scenario_fired_event").innerHTML = JSON.stringify(filteredScenarioFiredEvents, null, 2);

                const transactionsUrl = `https://amlglobalteam-03.unx.sas.com/amlCore/transactions?entityLevelCode=PTY&entityNumber=${actionableEntityId}`;
                const transactionsResponse = await fetch(transactionsUrl, requestOptions);
                if (!transactionsResponse.ok) {
                    throw new Error('Network response was not ok ' + transactionsResponse.statusText);
                }
                const transactionsData = await transactionsResponse.json();
                const filteredTransactions = transactionsData.items.map(transaction => ({
                    transactionNumber: transaction.transactionNumber,
                    primaryMediumDesc: transaction.primaryMediumDesc,
                    secondaryMediumDesc: transaction.secondaryMediumDesc,
                    mechanismDesc: transaction.mechanismDesc,
                    currencyAmount: transaction.currencyAmount,
                    transactionCDIDesc: transaction.transactionCDIDesc
                }));
                document.getElementById("transactions").innerHTML = JSON.stringify(filteredTransactions, null, 2);

                const partyInfoUrl = `https://amlglobalteam-03.unx.sas.com/SASVisualInvestigator/pages/PTY/${actionableEntityId}`;
                const partyInfoResponse = await fetch(partyInfoUrl, requestOptions);
                if (!partyInfoResponse.ok) {
                    throw new Error('Network response was not ok ' + partyInfoResponse.statusText);
                }
                const partyInfoData = await partyInfoResponse.json();
                document.getElementById("Party_info").innerHTML = JSON.stringify(partyInfoData.data, null, 2);

                const csrfToken = await getCsrfToken();
                await postData(csrfToken);
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('postResponse').textContent = `Error: ${error}`;
            }
        }

        document.getElementById("chatForm").addEventListener("submit", function () {
            console.log("[debug]: form submitted");
            event.preventDefault();
            console.log("[debug]: called api button");

            const apiKey = document.getElementById("apiKeyContainer").textContent;
            const apiUrl = "https://api.openai.com/v1/chat/completions";
            
            const model = document.getElementById("model").value;

            console.log("[debug]: ", apiKey);

            const userContent = `Please review the following account activity and identify any suspicious patterns or behaviors that could indicate potential money laundering. Focus on analyzing any large transactions, unusual frequency of activities, or connections to high-risk jurisdictions. Provide a detailed case narrative that includes an overview of the activity, specific transaction details, behavioral indicators, and how these activities align with the customer's KYC profile. Conclude with a risk assessment and recommendations for further action, such as enhanced due diligence or filing a SAR,

            Filtered Scenario Fired Events: ${document.getElementById("scenario_fired_event").textContent} 
            
            Filtered transactions: ${document.getElementById("transactions").textContent} 
            
            Personal information on the customer: ${document.getElementById("Party_info").textContent}
            `;

            
            console.log("[debug]: prompt: ", userContent);
            console.log("[debug]: model: ", model);

            const loading = document.getElementById("loading-indicator");

            const cost = costs[model];


            fetch(apiUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + apiKey
                },
                body: JSON.stringify({
                    "model": model,
                    "messages": [
                        {
                            "role": "user",
                            "content": userContent
                        }
                    ]
                })
            })
                .then(response => response.json())
                .then(data => {
                    loading.classList.toggle("loading");
                    console.log("[debug]: chatgpt response", data);
                    const content = data.choices[0].message.content;
                    const inputTokens = data.usage.prompt_tokens;
                    const outputTokens = data.usage.completion_tokens;

                    document.getElementById("chatgptResponse").textContent = content;

                    const inputPrice = (inputTokens * cost.input).toFixed(6);
                    const outputPrice = (outputTokens * cost.output).toFixed(6);

                    document.getElementById("input-token").textContent = `Input tokens: ${inputTokens} (Cost: $${inputPrice})`;
                    document.getElementById("output-tokens").textContent = `Output tokens: ${outputTokens} (Cost: $${outputPrice})`;
                    
                    // log it to job execution
                    callJob(inputTokens, outputTokens);
                })
                .catch(error => {
                    loading.classList.toggle("loading");
                    console.error("[debug]: Error:", error);
                    document.getElementById("chatgptResponse").textContent = "Error occurred while fetching API data.";
                });
        });

        // calls the job on SASJobExecution
        async function callJob(inputTokens, outputTokens) {
            console.log("[debug]: called job execution");
            const vajson = {
                "inputTokens": inputTokens,
                "outputTokens": outputTokens
            }

            const paramStr = "?_program="
                + encodeURIComponent("/Public/Report/Prices")
                + "&_action=" + encodeURIComponent("execute")
                + "&_outputType=ods_html5"
                + "&vajson=" + encodeURIComponent(JSON.stringify(vajson));
            + "&_debug=log"
                ;

            try {
                const url = "/SASJobExecution/" + paramStr;

                console.log("[debug]: Job URL: ", url);
                console.log("[debug]: ", vajson);

                const requestHeaders = new Headers();
                requestHeaders.append("Accept", "text/html");

                const requestOptions = {};
                requestOptions.headers = requestHeaders;
                requestOptions.method = "GET";

                const response = await fetch(url, requestOptions);

                if (!response.ok) {
                    const error = response.statusText;
                    console.log("[debug]: Job failed with error: ", error);
                }

                const jobOutput = await response.text();
                console.log("[debug]: Job output: ", jobOutput);
                return jobOutput;
            }
            catch (error) {
                console.error("************** JOB FAILED ***************");
                console.error("[debug]: Error: ", error);
            }
        }

        // Fetch data on page load
        document.addEventListener("DOMContentLoaded", function () {
            fetchData();
        });
    </script>
</body>

</html>
